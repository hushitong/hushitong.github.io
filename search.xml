<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASP.NET Core使用JWT</title>
    <url>/2022/02/+ASP.NETCore%E4%BD%BF%E7%94%A8JWT/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="有关JWT的基础"><a href="#有关JWT的基础" class="headerlink" title="有关JWT的基础"></a>有关JWT的基础</h2><p>看这文章之前需要先对JWT有了解，不过这部分已经有很多很好的文章，这边我就不再叙述，你可以看如 <a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权4:JwtBearer认证</a> 前面的介绍。</p>
<h2 id="ASP-NET-Core使用JWT"><a href="#ASP-NET-Core使用JWT" class="headerlink" title="ASP.NET Core使用JWT"></a>ASP.NET Core使用JWT</h2><p>这里我按照正常项目那样，分成两个项目，JWT.Server项目负责生成JWT，JWT.DemoApi则负责提供Api接口服务对于受限接口会验证JWT。</p>
<span id="more"></span>

<h3 id="JWT-Server生成JWT"><a href="#JWT-Server生成JWT" class="headerlink" title="JWT.Server生成JWT"></a>JWT.Server生成JWT</h3><ol>
<li><p>新建ASP.NET Core WebApi项目，我这里使用了3.1版本</p>
</li>
<li><p>nuget安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 需要根据自己的.net core版本选择相应版本</span><br><span class="line">Install-Package Microsoft.AspNetCore.Authentication.JwtBearer</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>appsettings.json</code>中添加上JWT相关配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Jwt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//密钥，需要大于等于16个字符，生产中密钥当然不能如下面这么简单</span></span><br><span class="line">  <span class="attr">&quot;Secret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789@qwerasdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//签发者</span></span><br><span class="line">  <span class="attr">&quot;Iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hushitong.github.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//使用者</span></span><br><span class="line">  <span class="attr">&quot;Aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//设置过期时间</span></span><br><span class="line">  <span class="attr">&quot;ExpireSeconds&quot;</span><span class="punctuation">:</span> <span class="number">300</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建<code>JWTController</code>，添加生成JWT相关代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">JWT.Server.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">JWTController</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Authenticate</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> pwd</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实际项目这里应该做登陆验证，这里就写死了</span></span><br><span class="line">            <span class="keyword">if</span> (userName == <span class="string">&quot;admin&quot;</span> &amp;&amp; pwd == <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> jwtConfig = configuration.GetSection(<span class="string">&quot;Jwt&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定义签名使用的密钥，以及使用Hmacsha256签名算法</span></span><br><span class="line">                <span class="keyword">var</span> securityKey = <span class="keyword">new</span> SigningCredentials(<span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Secret&quot;</span>))), SecurityAlgorithms.HmacSha256);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//有效载荷</span></span><br><span class="line">                <span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Iss,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Aud,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;1&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                SecurityToken securityToken = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">                    signingCredentials: securityKey,</span><br><span class="line">                    expires: DateTime.Now.AddSeconds(jwtConfig.GetValue&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;ExpireSeconds&quot;</span>)), <span class="comment">//过期时间</span></span><br><span class="line">                    claims: claims</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//生成jwt令牌</span></span><br><span class="line">                <span class="keyword">return</span> Content(<span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(securityToken));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试访问接口，可获得JWT</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODA4NjU0fQ.aqdRxdA9CakK_jrz-J3jTn2Rgu_2WkriHtLCJC61IcM</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JWT-DemoApi使用JWT验证"><a href="#JWT-DemoApi使用JWT验证" class="headerlink" title="JWT.DemoApi使用JWT验证"></a>JWT.DemoApi使用JWT验证</h3><ol>
<li><p>新建ASP.NET Core WebApi项目，我这里使用了3.1版本</p>
</li>
<li><p>nuget安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 需要根据自己的.net core版本选择相应版本</span><br><span class="line">Install-Package Microsoft.AspNetCore.Authentication.JwtBearer</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>appsettings.json</code>中添加上JWT相关配置，注意配置内容与JWT.Server里的基本一致，只是少了<code>ExpireSeconds</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Jwt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//密钥，需要大于等于16个字符，生产中密钥当然不能如下面这么简单</span></span><br><span class="line">  <span class="attr">&quot;Secret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789@qwerasdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//签发者</span></span><br><span class="line">  <span class="attr">&quot;Iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hushitong.github.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//使用者</span></span><br><span class="line">  <span class="attr">&quot;Aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Startup.ConfigureServices</code>里注册JWT</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得使用的密钥</span></span><br><span class="line"><span class="keyword">var</span> jwtConfig = Configuration.GetSection(<span class="string">&quot;Jwt&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> signingKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Secret&quot;</span>)));</span><br><span class="line"><span class="comment">//认证参数</span></span><br><span class="line">services.AddAuthentication(<span class="string">&quot;Bearer&quot;</span>)</span><br><span class="line">    .AddJwtBearer(o =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        o.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">        &#123;</span><br><span class="line">            ValidateIssuerSigningKey = <span class="literal">true</span>,<span class="comment">//是否验证签名,不验证的画可以篡改数据，不安全</span></span><br><span class="line">            IssuerSigningKey = signingKey,<span class="comment">//使用的密钥</span></span><br><span class="line">            ValidateIssuer = <span class="literal">true</span>,<span class="comment">//是否验证签发者，就是验证载荷中的Iss是否对应ValidIssuer参数</span></span><br><span class="line">            ValidIssuer = jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>),<span class="comment">//签发者</span></span><br><span class="line">            ValidateAudience = <span class="literal">true</span>,<span class="comment">//是否验证使用者，就是验证载荷中的Aud是否对应ValidAudience参数</span></span><br><span class="line">            ValidAudience = jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>),<span class="comment">//使用者</span></span><br><span class="line">            ValidateLifetime = <span class="literal">true</span>,<span class="comment">//是否验证过期时间，过期了就拒绝访问</span></span><br><span class="line">            ClockSkew = TimeSpan.Zero,<span class="comment">//这个是缓冲过期时间，也就是说，即使我们配置了过期时间，这里也要考虑进去，过期时间+缓冲，默认好像是7分钟，你可以直接设置为0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>确保<code>Startup.Configure</code>方法中添加 了 <code>app.UseAuthorization()</code>及<code>app.UseAuthentication()</code>，没有就加上</p>
<p>注意：<code>app.UseAuthentication()</code>你不加应用也不会报错，但是后续请求需要JWT验证的接口时会一直报401错误。</p>
</li>
<li><p>新建<code>JWTTestController</code>，添加相关测试代码，需要JWT验证的需要在Action上加上特性<code>[Authorize]</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTTestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不需要验证JWT</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithoutAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只验证JWT是否通过</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">Authorize</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用HttpContext.User.Claims可以获得当前用户Payload里的信息</span></span><br><span class="line">        HttpContext.User.Claims.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证JWT是否通过同时还得验证其payload中是否由符合SuperAdmin的Role</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">Authorize(Roles =<span class="string">&quot;SuperAdmin&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithRoleAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JWT测试"><a href="#JWT测试" class="headerlink" title="JWT测试"></a>JWT测试</h3><p>准备工作：运行JWT.Server，获得JWT</p>
<h4 id="访问JWT-DemoApi请求头不带JWT"><a href="#访问JWT-DemoApi请求头不带JWT" class="headerlink" title="访问JWT.DemoApi请求头不带JWT"></a>访问JWT.DemoApi请求头不带JWT</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br><span class="line"></span><br><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br></pre></td></tr></table></figure>

<p>可以看到添加了<code>[Authorize]</code>特性的接口都返回401 <em>(401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息)</em></p>
<h4 id="访问JWT-DemoApi请求头带JWT"><a href="#访问JWT-DemoApi请求头带JWT" class="headerlink" title="访问JWT.DemoApi请求头带JWT"></a>访问JWT.DemoApi请求头带JWT</h4><p>使用Postman或其他你顺手的工具，在请求头加上<code>Authorization: Bearer JWTString</code>，即可使用JWT测试，我这里使用的时Swagger带JWT的办法。</p>
<p>结果如下：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line"> curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：403</span><br><span class="line">  Error: response status is 403</span><br></pre></td></tr></table></figure>

<p>请求头添加了JWT参数后，<code>GetWithAuth</code>接口成功，但是<code>GetWithRoleAuth</code>却是返回403 <em>(403 forbidden，表示对请求资源的访问被服务器拒绝)</em> ，这是因为该接口有特性<code>[Authorize(Roles =&quot;SuperAdmin&quot;)]</code>限定了需要有SuperAdmin角色才能访问，而前面JWT.Server所发放的JWT里并不包含该角色，想要测试通过，只需要在JWT.Server发放JWT时payload里添加上SuperAdmin角色，重新生成JWT再测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有效载荷</span></span><br><span class="line"><span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Iss,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Aud,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">    <span class="comment">//这里添加SuperAdmin角色</span></span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;SuperAdmin&quot;</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="访问JWT-DemoApi请求头带过期的JWT"><a href="#访问JWT-DemoApi请求头带过期的JWT" class="headerlink" title="访问JWT.DemoApi请求头带过期的JWT"></a>访问JWT.DemoApi请求头带过期的JWT</h4><p>我们获得JWT后，等待300秒（前面设定的）让其过期，然后测试，结果和 <a href="#%E8%AE%BF%E9%97%AEJWT-DemoApi%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%B8%A6JWT">访问JWT.DemoApi请求头不带JWT</a> 一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br></pre></td></tr></table></figure>

<h2 id="TokenValidationParameters常用内容说明"><a href="#TokenValidationParameters常用内容说明" class="headerlink" title="TokenValidationParameters常用内容说明"></a>TokenValidationParameters常用内容说明</h2><p><code>TokenValidationParameters</code>是和token验证有关的参数配置，进行token验证时需要用到，下面是我对着该类写常用内容说明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenValidationParameters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Token最大占用空间：250 KB (kilobytes).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> DefaultMaximumTokenSizeInBytes = <span class="number">256000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的缓冲过期时间为：300seconds (5 minutes).</span></span><br><span class="line">    <span class="comment">// 真实过期时间 = 过期时间 + 缓冲过期时间</span></span><br><span class="line">    [<span class="meta">DefaultValue(300)</span>]</span><br><span class="line">    <span class="keyword">public</span> TimeSpan ClockSkew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要求token必须包含过期时间。默认为true，即Jwt的Payload部分必须包含exp且具有有效值。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireExpirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否验证token是否在有效期内，即验证Jwt的Payload部分的nbf和exp。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateLifetime</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否必须有签名部分，默认为true</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireSignedTokens;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于验证Jwt签名的密钥。</span></span><br><span class="line">    <span class="comment">//对于对称加密来说，加签和验签都是使用的同一个密钥；</span></span><br><span class="line">    <span class="comment">//对于非对称加密来说，使用私钥加签，然后使用公钥验签。</span></span><br><span class="line">    <span class="keyword">public</span> SecurityKey IssuerSigningKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 受众</span></span><br><span class="line">    <span class="comment">//是否必须有受众，默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireAudience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否验证受众，默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateAudience</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的受众，默认为null。ValidateAudience为true时，对比该值与Jwt的Payload部分的aud。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ValidAudience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的受众列表，可以指定多个受众,，默认为null。</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; ValidAudiences;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 签发者</span></span><br><span class="line">    <span class="comment">//是否验证签发者。默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateIssuer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的签发者，默认为null，ValidateIssuer为true时，对比该值与Jwt的Payload部分的iss。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ValidIssuer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的签发者列表，可以指定多个签发者,，默认为null。</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; ValidIssuers;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当token验证通过后，是否保存到Microsoft.AspNetCore.Authentication.AuthenticationProperties，默认false。</span></span><br><span class="line">    <span class="comment">//该操作发生在执行完JwtBearerEvents.TokenValidated之后。</span></span><br><span class="line">    <span class="comment">//想在后面代码里使用HttpContext.User.Claims可以获得当前用户Payload里的信息的话，需要设置true</span></span><br><span class="line">    [<span class="meta">DefaultValue(false)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SaveSigninToken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，可以看到其默认设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TokenValidationParameters</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RequireExpirationTime = <span class="literal">true</span>;</span><br><span class="line">        RequireSignedTokens = <span class="literal">true</span>;</span><br><span class="line">        RequireAudience = <span class="literal">true</span>;</span><br><span class="line">        SaveSigninToken = <span class="literal">false</span>;</span><br><span class="line">        ValidateActor = <span class="literal">false</span>;</span><br><span class="line">        ValidateAudience = <span class="literal">true</span>;</span><br><span class="line">        ValidateIssuer = <span class="literal">true</span>;</span><br><span class="line">        ValidateIssuerSigningKey = <span class="literal">false</span>;</span><br><span class="line">        ValidateLifetime = <span class="literal">true</span>;</span><br><span class="line">        ValidateTokenReplay = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JwtBearerEvents"><a href="#JwtBearerEvents" class="headerlink" title="JwtBearerEvents"></a>JwtBearerEvents</h2><p>在验证JWT时，<code>Microsoft.AspNetCore.Authentication.JwtBearer</code>同时提供了一些额外事件来提供更有力的支持。</p>
<h3 id="OnMessageReceived事件"><a href="#OnMessageReceived事件" class="headerlink" title="OnMessageReceived事件"></a>OnMessageReceived事件</h3><p>假设我们的接口会接受网页与App端请求，网页使用Cookies保存JWT信息，而App使用请求头。</p>
<p>那我们需要在请求头中获得不了JWT信息时，再尝试去Cookie中获取，我们可以使用<code>OnMessageReceived</code>事件解决该需求。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册时添加OnMessageReceived</span></span><br><span class="line">services.AddAuthentication(<span class="string">&quot;Bearer&quot;</span>).AddJwtBearer(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//省略一些设置</span></span><br><span class="line">    </span><br><span class="line">    o.Events = <span class="keyword">new</span> JwtBearerEvents()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该事件会在收到请求在验证JWT前触发</span></span><br><span class="line">        OnMessageReceived = context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//假如在Header中没有包含JWT的参数，那就到Cookies去找</span></span><br><span class="line">            <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(<span class="string">&quot;Authorization&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获取到Cookies中的access_token，后续验证使用该token，并且在控制台输出</span></span><br><span class="line">                context.Token = context.Request.Cookies[<span class="string">&quot;access_token&quot;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个接口，在Cookies中添加access_token</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">SetCookiesToken</span>(<span class="params"><span class="built_in">string</span> access_token</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HttpContext.Response.Cookies.Append(<span class="string">&quot;access_token&quot;</span>, access_token);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;设置Cookies成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由JWT.Server获得JWT后，先访问<code>SetCookiesToken</code>接口设置token，然后你就不需要再在请求头中添加JWT参数，同样可以访问需要验证接口，结果同 <a href="#%E8%AE%BF%E9%97%AEJWT.DemoApi%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%B8%A6JWT">访问JWT.DemoApi请求头带JWT</a></p>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><p>通过查看<code>Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents</code>，发现除了<code>OnMessageReceived</code>事件外，还提供了如下几个事件：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.AspNetCore.Authentication.JwtBearer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specifies events which the Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler invokes to enable developer control over the authentication process.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JwtBearerEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Invoked if exceptions are thrown during request processing. The exceptions will be re-thrown after this event unless suppressed.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;AuthenticationFailedContext, Task&gt; OnAuthenticationFailed</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked if Authorization fails and results in a Forbidden response</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;ForbiddenContext, Task&gt; OnForbidden</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked when a protocol message is first received.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;MessageReceivedContext, Task&gt; OnMessageReceived</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked after the security token has passed validation and a ClaimsIdentity has been generated.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;TokenValidatedContext, Task&gt; OnTokenValidated</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked before a challenge is sent back to the caller.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;JwtBearerChallengeContext, Task&gt; OnChallenge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制JWT失效"><a href="#强制JWT失效" class="headerlink" title="强制JWT失效"></a>强制JWT失效</h2><p>使用JWT本身是有一个问题的，那就是JWT本身在过期时间前都是有效的，这就会导致一些问题，如：账号被封后仍然能用，账号下线后实际其JWT仍可能被其他人利用，账号权限更改后不能实时生效等。</p>
<p>有一些其他办法解决该问题，我这里提供其中一种办法，就是每个用户新对应一个JWTGenerations字段（int类型，从1开始，写入数据库）</p>
<ul>
<li><p>签发端：</p>
<p>在JWT的Payload部分添加一个新字段<code>Generations</code>，其值为最新的JWTGenerations值。</p>
</li>
<li><p>服务端：</p>
<p>验证JWT时，同时拿其<code>Generations</code>与最新的JWTGenerations值比较，只要小于最新的JWTGenerations值，那判定该JWT失效，让其重新登陆。</p>
</li>
</ul>
<p>每当进行使该用户JWT失效的操作（如：用户登陆、用户登出、用户被封等）时，让该用户JWTGenerations值+1。</p>
<p>JWTGenerations值在可以使用Redis等缓存保存以提升速度，然后每过10秒左右（时间根据实际自己定）主动去数据库拉取最新数据，也可以在进行使该用户JWT失效的操作后主动更新该信息都可以。</p>
<p><strong>注意</strong>：该方案会造成只允许一个账号只能在一端登陆，其他端会被下线，需要其他办法再支持。</p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p><a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权4:JwtBearer认证</a></p>
<p><a href="https://www.cnblogs.com/7tiny/p/11019698.html">asp.net core 集成JWT（二）token的强制失效，基于策略模式细化api权限</a></p>
<p><a href="https://www.cnblogs.com/xiaoxiaotank/p/15882735.html">理解ASP.NET Core - 基于JwtBearer的身份认证(Authentication) </a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>ASP.Net Core</tag>
        <tag>EF Core</tag>
        <tag>JWT</tag>
        <tag>Auth</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore使用Swagger</title>
    <url>/2022/01/+ASP.NETCore%E4%BD%BF%E7%94%A8Swagger/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a>什么是swagger</h2><p><a href="https://swagger.io/">swagger</a>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。</p>
<p>简单来讲，使用swagger能够自动生成友好的在线接口文档，并且支持接口测试，其好处：</p>
<ul>
<li>对后端人员：减少了编写接口后还要花费时间同步更新接口文档，且与前端沟通的时间成本。</li>
<li>对前端人员：能够直观的快速的看到接口，并且进行在线测试，方便了调试调用接口，不用因接口问题频繁与后端沟通。</li>
</ul>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>框架.net3.1默认没有swagger，需要自己弄，以下简单写步骤</p>
<ol>
<li><p>nuget安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Swashbuckle.AspNetCore</span><br></pre></td></tr></table></figure></li>
<li><p>Startup.cs文件引入命名空间</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Swashbuckle.AspNetCore.Swagger;</span><br><span class="line"><span class="keyword">using</span> Microsoft.OpenApi.Models;</span><br></pre></td></tr></table></figure></li>
<li><p>将 Swagger 生成器添加到 <code>Startup.ConfigureServices</code> 方法中的服务集合中</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>Startup.Configure</code> 方法中，启用中间件为生成的 JSON 文档和 Swagger UI 提供服务</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>此时启动项目就可通过<code>http://localhost:&lt;port&gt;/swagger</code>地址访问Swagger UI浏览API文档。</p>
<p>   也可通过<code>http://localhost:&lt;port&gt;/swagger/v1/swagger.json</code>地址访问生成的描述终结点的json文档。</p>
</li>
<li><p>如果要想通过<code>http://localhost:&lt;port&gt;/</code>就访问Swagger UI，修改启用中间件SwaggerUI的方法<code>UseSwaggerUI</code>，把<code>RoutePrefix</code> 属性设置为空字符串。</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="添加版本控制"><a href="#添加版本控制" class="headerlink" title="添加版本控制"></a>添加版本控制</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>添加API枚举类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 版本控制</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ApiVersion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v1版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V1 = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v2版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V2 = <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历版本信息</span></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerDoc(version, <span class="keyword">new</span> OpenApiInfo</span><br><span class="line">        &#123;</span><br><span class="line">            Version = version, <span class="comment">//版本号</span></span><br><span class="line">            Title = <span class="string">$&quot;My API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//标题</span></span><br><span class="line">            Description = <span class="string">$&quot;My ASP.NET Core Web API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//描述</span></span><br><span class="line">            <span class="comment">//上面三项最后设置，下面的三项可以不用</span></span><br><span class="line">            TermsOfService = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/terms&quot;</span>), <span class="comment">//服务条款</span></span><br><span class="line">            Contact = <span class="keyword">new</span> OpenApiContact</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Singo&quot;</span>, <span class="comment">//联系人</span></span><br><span class="line">                Email = <span class="built_in">string</span>.Empty,  <span class="comment">//邮箱</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://github.com/hushitong&quot;</span>),<span class="comment">//网站</span></span><br><span class="line">            &#125;,</span><br><span class="line">            License = <span class="keyword">new</span> OpenApiLicense</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Use under LICX&quot;</span>, <span class="comment">//协议</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/license&quot;</span>), <span class="comment">//协议地址</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.Configure</code> 里启用中间件的设置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//描述终结点的json文档</span></span><br><span class="line">        c.SwaggerEndpoint(<span class="string">$&quot;/swagger/<span class="subst">&#123;version&#125;</span>/swagger.json&quot;</span>, version);</span><br><span class="line">        <span class="comment">//设置为none可折叠所有方法</span></span><br><span class="line">        c.DocExpansion(Swashbuckle.AspNetCore.SwaggerUI.DocExpansion.None);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>然后就是使用ApiExplorerSettingsAttribute标注各个版本Controller，然后修改路由信息</p>
<p>原来的标注为</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V1))</span>]</span><br></pre></td></tr></table></figure>

<p>后来的根据需要标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V2))</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>启动后就可以通过右上角的下拉框选择需要的版本进行测试了</p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有关版本控制实际有很多办法，如：可以查看<a href="https://www.cnblogs.com/Leo_wl/p/7508650.html">Net Core WebApi几种版本控制对比</a></p>
<h2 id="添加JWT支持"><a href="#添加JWT支持" class="headerlink" title="添加JWT支持"></a>添加JWT支持</h2><ol>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 添加JWT支持</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">&quot;Bearer&quot;</span>, <span class="keyword">new</span> OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = <span class="string">&quot;在下框中输入请求头中需要添加Jwt授权Token：Bearer Token&quot;</span>,</span><br><span class="line">        Name = <span class="string">&quot;Authorization&quot;</span>, <span class="comment">//设置其key名，请求时会添加上，默认使用Authorization名</span></span><br><span class="line">        In = ParameterLocation.Header, <span class="comment">//在请求头添加JWT Token</span></span><br><span class="line">        Type = SecuritySchemeType.ApiKey,</span><br><span class="line">        BearerFormat = <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">        Scheme = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    c.AddSecurityRequirement(<span class="keyword">new</span> OpenApiSecurityRequirement</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">            &#123;</span><br><span class="line">                Reference = <span class="keyword">new</span> OpenApiReference &#123;</span><br><span class="line">                    Type = ReferenceType.SecurityScheme,</span><br><span class="line">                    Id = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>运行进入SeaggerUI页面，可以看到在页面右上角多了一个<code>Authorize</code>按钮，点击在value框可以填入<code>bear &lt;your jwt string&gt;</code>，以后请求头都会带上<code>Authorization: bear &lt;your jwt string&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/SwaggerWithJWT.png" alt="SwaggerWithJWT"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>文档</tag>
        <tag>Swagger</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore如何解密Cookie</title>
    <url>/2022/02/+ASP.NETCore%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86Cookie/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事情的起点就在于我在弄ASP .NET Core下的OAuth2.0流程，想要看看具体的Cookie信息有哪些，发现Cookie信息被加密了，检索了一番，发现了解决办法 <a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86Cookie">如何解密Cookie</a> ，然后顺便找了一下原理。</p>
<h2 id="如何解密Cookie"><a href="#如何解密Cookie" class="headerlink" title="如何解密Cookie"></a>如何解密Cookie</h2><p>主要代码来源：<a href="https://stackoverflow.com/questions/42842511/how-to-manually-decrypt-an-asp-net-core-authentication-cookie">How to manually decrypt an ASP.NET Core Authentication cookie?</a></p>
<span id="more"></span>

<ol>
<li><p><code>Startup.CongigureServices</code>里注册的部分代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddAuthentication(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//但我们登陆后，设置Cookie</span></span><br><span class="line">    config.DefaultSignInScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">    <span class="comment">//使用作为验证是否登陆</span></span><br><span class="line">    config.DefaultAuthenticateScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">&#125;).AddCookie(<span class="string">&quot;MyCookieScheme&quot;</span>, options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置密钥存储位置，你也可以使用services.AddDataProtection().PersistKeysToFileSystem(new DirectoryInfo(@&quot;C:\temp-keys2\&quot;))</span></span><br><span class="line">    options.DataProtectionProvider = DataProtectionProvider.Create(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;C:\temp-keys\&quot;</span>));</span><br><span class="line">    options.Cookie.Name = <span class="string">&quot;MyClientCookie&quot;</span>; <span class="comment">//默认为：.AspNetCore.Cookies</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>解密Cookie</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">DecryptCookie</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获得加密了的Cookie值，Cookie名假如注册时候没指定的话为：.AspNetCore.Cookies</span></span><br><span class="line">    <span class="built_in">string</span> cookieValue = HttpContext.Request.Cookies[<span class="string">&quot;MyClientCookie&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Create方法生成DataProtectionProvider对象，密钥存储位置值与在ConfigureServices注册时一致</span></span><br><span class="line">    <span class="keyword">var</span> provider = DataProtectionProvider.Create(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;C:\temp-keys\&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得DataProtector对象，第二个参数的值你在注册Cookies时候设定的Scheme名，没有设定的话其默认值为：Cookies</span></span><br><span class="line">    <span class="keyword">var</span> dataProtector = provider.CreateProtector(<span class="string">&quot;Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationMiddleware&quot;</span>, <span class="string">&quot;MyCookieScheme&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解密Cookie值，变为普通文本</span></span><br><span class="line">    <span class="built_in">byte</span>[] protectedBytes = Base64UrlTextEncoder.Decode(cookieValue);</span><br><span class="line">    <span class="built_in">byte</span>[] plainBytes = dataProtector.Unprotect(protectedBytes);</span><br><span class="line">    <span class="built_in">string</span> plainText = Encoding.UTF8.GetString(plainBytes);</span><br><span class="line">    <span class="comment">//上面的Encoding.UTF8.GetString不行的话使用下面的</span></span><br><span class="line">    <span class="comment">//UTF8Encoding specialUtf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false);</span></span><br><span class="line">    <span class="comment">//string plainText = specialUtf8Encoding.GetString(plainBytes);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或解密Cookie值，转换为AuthenticationTicket对象</span></span><br><span class="line">    TicketDataFormat ticketDataFormat = <span class="keyword">new</span> TicketDataFormat(dataProtector);</span><br><span class="line">    AuthenticationTicket ticket = ticketDataFormat.Unprotect(cookieValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(JsonConvert.SerializeObject(ticket.Properties.Items));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li><p>最重要的是设置保存到 <code>C:\temp-keys\</code> 下的私钥文件，有了这文件，你加密的Cookie能被任何人解密。</p>
</li>
<li><p>当然你可以不存储到文件，还有其他办法，具体参考：<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/implementation/key-storage-providers">ASP.NET Core 中的密钥存储提供程序</a></p>
</li>
</ul>
<h2 id="简单说说原理"><a href="#简单说说原理" class="headerlink" title="简单说说原理"></a>简单说说原理</h2><h3 id="默认Cookie不加密"><a href="#默认Cookie不加密" class="headerlink" title="默认Cookie不加密"></a>默认Cookie不加密</h3><p>当我们直接添加的Cookie默认是不经过加密的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HttpContext.Response.Cookies.Append(<span class="string">&quot;web_nmae&quot;</span>,<span class="string">&quot;MyWeb&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="认证-Authentication-使用Cookie认证方案时认证信息加密"><a href="#认证-Authentication-使用Cookie认证方案时认证信息加密" class="headerlink" title="认证(Authentication)使用Cookie认证方案时认证信息加密"></a>认证(Authentication)使用Cookie认证方案时认证信息加密</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line">services.AddAuthentication(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//但我们登陆后，设置Cookie</span></span><br><span class="line">    config.DefaultSignInScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">    <span class="comment">//使用作为验证是否登陆</span></span><br><span class="line">    config.DefaultAuthenticateScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">&#125;).AddCookie(<span class="string">&quot;MyCookieScheme&quot;</span>, options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//options.DataProtectionProvider = DataProtectionProvider.Create(new DirectoryInfo(@&quot;C:\temp-keys\&quot;));</span></span><br><span class="line">    options.Cookie.Name = <span class="string">&quot;MyClientCookie&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SignIn接口</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SignIn</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;singo&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;4433&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    ClaimsIdentity claimsIdentity = <span class="keyword">new</span> ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);</span><br><span class="line">    <span class="keyword">var</span> claimsPrincipal = <span class="keyword">new</span> ClaimsPrincipal(claimsIdentity);</span><br><span class="line">    <span class="keyword">await</span> HttpContext.SignInAsync(claimsPrincipal);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;SignIn成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">SetCookie</span>(<span class="params"><span class="built_in">string</span> key,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用该方法设置Cookie不会被加密</span></span><br><span class="line">    HttpContext.Response.Cookies.Append(key, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;SetCookie成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用SignIn接口，查看Cookies，就能发现一个Cookie项，其value被加密了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">key: MyClientCookie</span><br><span class="line">value: CfDJ8FY8TudSY7lKgK5Kc1rjrPANTxtvOw87CVoObdVDdNug6_nTvgFZWRANLhPQBRrrhBQjWItfG51Xsdc1SaXDRTBDfxLWl-iSzKX5NnUUf3U9hM5ptcrXkPbDnvZKWtjtgr9gY1A5lIbqsZTjDwrQR5jNBxu81LzCz8_vJBRma2yrmjc9UIc_3vyxXX5pkMWk1Rt6-QHXFuRUdHbHjuN_jRckKFmzIUHJ_dlpzTGbhwTeMRLUJwAJT6zP56XeR_A_k00GEULumSHYqCopbhOKHe89kA75_tuj2Sg1EPVK0oJ1DfGIusleH3qdbWN4ZRsFQ0QLYdalm05i0r1nx_cbGJPQhT0thFqNj-zdOkXKaEEZvGrl6kSQr4NM0IhtBed2HeibJsw9gSKVCNiQAPTMVoGnVnM4cr6A1e6uyEn9CO4IB-VhjULeE8GT0BJ0nD6VatLKq6aXbxVS5Mwfnhs4ZgxpFJ_u-IY3hL3joOYfmAcIJi1R3XFypmPAAp3AeMHn9qIuxKpCDF8ybQSPqRn_wIfLA9KUt5WGlZX5y_nvdfiX-HaPEmytZtyi69k5MPZxmOAeTHh9r1i6HCRYN6veFmjDC7y7kJhSxvxiWePmTfHx</span><br></pre></td></tr></table></figure>

<h3 id="查看HttpContext-SignInAsync源码"><a href="#查看HttpContext-SignInAsync源码" class="headerlink" title="查看HttpContext.SignInAsync源码"></a>查看HttpContext.SignInAsync源码</h3><p>然后去找源代码看，最后会发现其中的关键就是<code>CookieAuthenticationHandler.cs</code>文件下的<code>HandleSignInAsync</code>方法，我把其简化了贴出来</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">HandleSignInAsync</span>(<span class="params">ClaimsPrincipal user, AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Process the request cookie to initialize members like _sessionKey.</span></span><br><span class="line">    <span class="keyword">await</span> EnsureCookieTicket();</span><br><span class="line">    <span class="keyword">var</span> cookieOptions = BuildCookieOptions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> signInContext = <span class="keyword">new</span> CookieSigningInContext(</span><br><span class="line">        Context,</span><br><span class="line">        Scheme,</span><br><span class="line">        Options,</span><br><span class="line">        user,</span><br><span class="line">        properties,</span><br><span class="line">        cookieOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!signInContext.Properties.ExpiresUtc.HasValue)</span><br><span class="line">    &#123;</span><br><span class="line">        signInContext.Properties.ExpiresUtc = issuedUtc.Add(Options.ExpireTimeSpan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Events.SigningIn(signInContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signInContext.Properties.IsPersistent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> expiresUtc = signInContext.Properties.ExpiresUtc ?? issuedUtc.Add(Options.ExpireTimeSpan);</span><br><span class="line">        signInContext.CookieOptions.Expires = expiresUtc.ToUniversalTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ticket = <span class="keyword">new</span> AuthenticationTicket(signInContext.Principal!, signInContext.Properties, signInContext.Scheme.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里加密cookieValue</span></span><br><span class="line">    <span class="comment">//当你点到TicketDataFormat，会有提示如下</span></span><br><span class="line">    <span class="comment">//The TicketDataFormat is used to protect and unprotect the identity and other properties which are stored in the</span></span><br><span class="line">    <span class="comment">//cookie value. If not provided one will be created using &lt;see cref=&quot;DataProtectionProvider&quot;/&gt;.</span></span><br><span class="line">    <span class="keyword">var</span> cookieValue = Options.TicketDataFormat.Protect(ticket, GetTlsTokenBinding());</span><br><span class="line"></span><br><span class="line">    Options.CookieManager.AppendResponseCookie(</span><br><span class="line">        Context,</span><br><span class="line">        Options.Cookie.Name!,</span><br><span class="line">        cookieValue,</span><br><span class="line">        signInContext.CookieOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> signedInContext = <span class="keyword">new</span> CookieSignedInContext(</span><br><span class="line">        Context,</span><br><span class="line">        Scheme,</span><br><span class="line">        signInContext.Principal!,</span><br><span class="line">        signInContext.Properties,</span><br><span class="line">        Options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Events.SignedIn(signedInContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only redirect on the login path</span></span><br><span class="line">    <span class="keyword">var</span> shouldRedirect = Options.LoginPath.HasValue &amp;&amp; OriginalPath == Options.LoginPath;</span><br><span class="line">    <span class="keyword">await</span> ApplyHeaders(shouldRedirect, signedInContext.Properties);</span><br><span class="line"></span><br><span class="line">    Logger.AuthenticationSchemeSignedIn(Scheme.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后的加密的依赖就是 <code>Data Protection</code></p>
<h3 id="Data-Protection"><a href="#Data-Protection" class="headerlink" title="Data Protection"></a><strong><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/introduction">Data Protection</a></strong></h3><blockquote>
<p>Data Protection是微软提供的数据保护机制：</p>
<p>为了确保Web应用敏感数据的安全存储，该机制提供了一个简单、基于非对称加密改进的、性能良好的、开箱即用的加密API用于数据保护。</p>
<p>它不需要开发人员专门学习怎么样管理这些钥（公钥，私钥），系统回自动的选择算法和管理密钥的生命周期。理想情况下开发人员都不应该访问这些钥的原始文件。</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当我们SignIn时会把认证信息给Data Protection加密然后存储到Cookie。</p>
<p>当我们获得其该Cookie进行认证时，该值又会被Data Protection给解密，默认该流程不需要用户设置，应用就会自动进行加解密。</p>
<h2 id="关于Data-Protection可扩展阅读"><a href="#关于Data-Protection可扩展阅读" class="headerlink" title="关于Data Protection可扩展阅读"></a>关于Data Protection可扩展阅读</h2><p><a href="https://www.cnblogs.com/savorboard/p/5778616.html">ASP.NET Core 数据保护（Data Protection）【上】</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html">ASP.NET Core 数据保护（Data Protection）【中】</a></p>
<p>官方文档：</p>
<p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/introduction">ASP.NET Core 数据保护</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>Data Protection</tag>
        <tag>Cookie</tag>
        <tag>解密</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core缓存</title>
    <url>/2022/01/+ASP.NETCore%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Caching通过减少生成内容所需的工作，显著提高应用的性能和可伸缩性。 Caching最适用于不经常更改且 <strong>生成成本高</strong> 的数据。 Caching可比从源返回快得多的数据副本。</p>
<p>ASP.NET Core支持多个不同的缓存</p>
<ul>
<li>客户端缓存 Cache-control</li>
<li>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></li>
<li>内存缓存  <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory">In-MemoryCache</a></li>
<li>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></li>
</ul>
<span id="more"></span>

<h2 id="缓存准则"><a href="#缓存准则" class="headerlink" title="缓存准则"></a>缓存准则</h2><ul>
<li>代码应始终具有用于提取数据的选项，而不是依赖于可用的缓存值。</li>
<li>缓存的是内存资源，内存资源是有限的因此需要限制缓存增长：<ul>
<li>请勿将外部输入用作缓存Key，如果任由外部输入作为Key，那缓存很容易就会被恶意刷爆。</li>
<li>使用过期时间策略限制缓存增长，这能够及时释放不活跃的缓存，及时释放内存空间。</li>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory?view=aspnetcore-3.1#use-setsize-size-and-sizelimit-to-limit-cache-size">使用 SetSize、Size 和 SizeLimit 限制缓存大小</a>。 ASP.NET Core运行时 <strong>不会根据</strong> 内存压力限制缓存大小。 由开发人员限制缓存大小。</li>
</ul>
</li>
</ul>
<h2 id="客户端缓存-Cache-control"><a href="#客户端缓存-Cache-control" class="headerlink" title="客户端缓存 Cache-control"></a>客户端缓存 Cache-control</h2><p>Http协议中规定，服务器端通过返回报文头添加Cache-control，来达到通知客户端进行缓存，如：<code>Cache-control:max-age=30</code>，表示让客户端缓存该内容30秒（当然客户端也可以不干）。</p>
<p>在ASP.NET Core中，可以通过添加<code>ResponseCacheAttribute</code>这个Attribute，让程序在返回时的添加报文头<code>Cache-control</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端缓存只对本客户端有效，在你使用另一个客户端发出一样的请求是，你就会发现访问的不是缓存了的数据，而是最新数据。这时候就需要使用服务端缓存了。</p>
<h2 id="服务器端响应缓存-ResponseCaching"><a href="#服务器端响应缓存-ResponseCaching" class="headerlink" title="服务器端响应缓存 ResponseCaching"></a>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></h2><p>ASP.NET Core不但可以设置浏览器缓存，还可以设置服务器端的响应缓存，当请求某资源时，响应的内容会被服务器进行缓存，在缓存有效期内，就算不同客户端获取同一资源也不会真的进入该资源地址获取数据，而是由缓存直接返回内容。</p>
<h3 id="使用ResponseCaching"><a href="#使用ResponseCaching" class="headerlink" title="使用ResponseCaching"></a>使用ResponseCaching</h3><p>要使用服务器缓存，需要以下步骤：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.Configure</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>同样需要添加<code>ResponseCacheAttribute</code>这个Attribute：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这时候你通过同一客户端多次访问该资源发现第二次以后的访问的是客户端缓存，通过不同客户端访问的是服务器缓存的内容。</p>
<h3 id="ResponseCaching的缓存条件"><a href="#ResponseCaching的缓存条件" class="headerlink" title="ResponseCaching的缓存条件"></a>ResponseCaching的缓存条件</h3><ul>
<li>请求必须生成状态代码为”正常”的 200 (服务器) 响应。</li>
<li>请求方法必须是 GET 或 HEAD。</li>
<li>在 <code>Startup.Configure</code> 中，Caching中间件的中间件之前必须放置需要缓存的中间件。 有关详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1">ASP.NET Core 中间件</a>。</li>
<li><code>Authorization</code>标头不能存在。</li>
<li><code>Cache-Control</code> 标头参数必须有效，并且响应必须标记 <code>public</code> 且未标记为 <code>private</code> 。</li>
<li>如果标头不存在，则标头不得存在，因为标头 <code>Pragma: no-cache</code> <code>Cache-Control</code> 将替代标头（ <code>Cache-Control</code> <code>Pragma</code> 如果存在）。</li>
<li><code>Set-Cookie</code>标头不能存在。</li>
<li><code>Vary</code> 标头参数必须有效且不等于 <code>*</code> 。</li>
<li>如果 <code>Content-Length</code> 设置了 (标头值) 必须与响应正文的大小匹配。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.features.ihttpsendfilefeature">IHttpSendFileFeature</a>未使用 。</li>
<li>响应不能像 标头和 和 缓存 <code>Expires</code> 指令所指定 <code>max-age</code> 一 <code>s-maxage</code> 样过时。</li>
<li>响应缓冲必须成功。 响应的大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.sizelimit#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_SizeLimit">SizeLimit</a> 。 响应的正文大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.maximumbodysize#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_MaximumBodySize">MaximumBodySize</a> 。</li>
<li>响应必须可缓存，符合 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 规范。 例如，指令 <code>no-store</code> 不得存在于请求或响应标头字段中。 有关详细信息 <em>，请参阅第 3</em> 部分：在 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 的缓存中存储响应。</li>
</ul>
<h3 id="ResponseCaching只是看上去美好"><a href="#ResponseCaching只是看上去美好" class="headerlink" title="ResponseCaching只是看上去美好"></a>ResponseCaching只是看上去美好</h3><p>虽然服务器端响应缓存看起来很美好，不过实际上有点中看不中用，应为其生效是有条件的，而且还挺苛刻，实际上只要请求的报文头加上<code>Cache-Control:no-cache</code>，就可以让服务器响应缓存失效。所以一般我们更加依赖于：<code>内存缓存</code>、<code>分布式缓存</code>。</p>
<h2 id="内存缓存-IMemoryCache"><a href="#内存缓存-IMemoryCache" class="headerlink" title="内存缓存  IMemoryCache"></a>内存缓存  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.memory.imemorycache">IMemoryCache</a></h2><p>内存缓存是数据保存在当前运行的网站的内存中，是与进程相关的。而由于在Web服务器中，多个不同网站时运行在不同进程中的，因此不同网站的内存时不会互相干扰的，也就意味着不能直接访问不在同一进程中的其他应用程序的内存缓存，然后需要注意的是网站重启后，内存缓存中的数据会清空。</p>
<h3 id="使用内存缓存"><a href="#使用内存缓存" class="headerlink" title="使用内存缓存"></a>使用内存缓存</h3><p>要使用内存缓存，需要：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddMemoryCache();</span><br></pre></td></tr></table></figure></li>
<li><p>注入<code>IMemoryCache</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = memoryCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>TryGetValue</code>、<code>Remove</code>、<code>Set</code>、<code>GetOrCreate</code>等方法操作MemoryCache</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryCacheController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = memoryCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strName = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一、使用TryGetValue与Set</span></span><br><span class="line">        <span class="comment">//if (!_cache.TryGetValue(&quot;Name&quot;, out strName))</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    strName = GetNmae(id);</span></span><br><span class="line">        <span class="comment">//    _cache.Set(&quot;Name&quot;, strName);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//方法二、使用GetOrCreate</span></span><br><span class="line">        <span class="comment">//strName = _cache.GetOrCreate&lt;string&gt;(&quot;Name&quot;, (e) =&gt; &#123; return GetNmae(id); &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Remove&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">string</span> cacheName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache.Remove(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetNmae</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;Singo&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="string">&quot;古月&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="literal">default</span>: <span class="keyword">return</span> <span class="string">&quot;无名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>访问<code>Get</code>方法获得数据并设置一个名字为”Name”的MemoryCache，在过期前再次访问获得的都是MemoryCache里的数据，可以通过访问<code>Remove</code>方法，传入参数”Name”，即可清除名字为”Name”的MemoryCache。</p>
<h3 id="过期时间策略"><a href="#过期时间策略" class="headerlink" title="过期时间策略"></a>过期时间策略</h3><p>默认情况下内存缓存是不会过期的，因此我们可以通过<code>Remove</code>方法删除缓存，或者使用<code>Set</code>方法重新设置缓存，不过在实际应用中大部分时间不会这么做，因为这么弄很麻烦，更常用的办法时使用过期时间来管理。</p>
<p>过期时间策略有两种</p>
<ul>
<li><p>绝对过期时间，通过设置<code>ICacheEntry.AbsoluteExpirationRelativeToNow</code>(过多少时间后失效)或<code>ICacheEntry.AbsoluteExpiration</code>(什么时间点失效)。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123; <span class="keyword">return</span> GetNmae(id); &#125;);</span><br><span class="line"><span class="comment">//5秒后过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在今天晚上23点失效</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpiration = System.DateTime.Today.AddHours(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>滑动过期时间，通过设置<code>ICacheEntry.SlidingExpiration</code>(过多少时间后失效，但是如果在失效前一直有访问尽量，那就会延长设置的时间（注意是在被访问的时间点上），直到过期。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5秒后过期，假如在过期前被访问，以被访问时间点位基准再次延迟5秒，直到过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.SlidingExpiration = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>不过可以混用两种策略，让缓存数据能够在滑动过期时间的基础上，通过设置绝对过期时间来达到强制刷新数据的目的，也就是说在绝对过期时间这个点数据必定过期，滑动时间影响不了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//混用绝对过期时间与滑动过期时间</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = System.TimeSpan.FromSeconds(<span class="number">15</span>);  <span class="comment">//绝对过期时间15秒</span></span><br><span class="line">    e.SlidingExpiration = System.TimeSpan.FromSeconds(<span class="number">5</span>);  <span class="comment">//滑动过期时间5秒</span></span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分布式缓存-DistributedCache"><a href="#分布式缓存-DistributedCache" class="headerlink" title="分布式缓存 DistributedCache"></a>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></h2><p>内存缓存在比较简单的应用里是足够使用的，但是对于现在需要多台服务器进行负载均衡的架构环境中就显得有点不太够用，如会出现：缓存内容不一致、多台服务器缓存同一内容浪费内存空间等问题，因此需要一个独立的统一的缓存存储中心，以便让所有的Web服务器共享同一份缓存数据，我们将这种缓存形式称为<strong>分布式缓存</strong>。</p>
<h3 id="有关-NET-Core的分布式缓存"><a href="#有关-NET-Core的分布式缓存" class="headerlink" title="有关.NET Core的分布式缓存"></a>有关.NET Core的分布式缓存</h3><ul>
<li><p>.NET Core没有内置分布式缓存，但是却提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法实际与内存缓存类似。</p>
</li>
<li><p>可以使用常用分布式缓存如<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>、<a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>、<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>、<a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>等。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>：缓存性能并不好，基本不考虑。</p>
<p><a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>：缓存专用，性能非常高能，可惜对集群、高可用方面支持比较弱，而且有<em>缓存键最大长度为250字节</em>（以前做项目刚用时就被坑过，超过了就直接截断，也没报错提醒）、<em>最大只能存储1MB的单个item</em>等限制。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>：虽然做缓存服务器的性能比Memcached稍差，但是其高可用、集群等方面非常强大，适合在数据量大及集群等场景使用，并且缓存外的功能也很强大，还能做消息队列等。</p>
<p><a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>：它是一个高性能的、分布式的、可扩展的、天生为.Net设计的缓存框架，NCache不仅比 Redis 快，而且还提供了一些Redis所不具有的分布式特性。</p>
</li>
<li><p>分布式缓存其缓存值的类型为<code>byte[]</code>，虽然也提供了接受string的类型的方法，但是最终都会转换为<code>byte[]</code>，而且本身IDistributedCache提供的方法有限，最好扩展IDistributedCache的方法。</p>
</li>
</ul>
<h3 id="IDistributedCache接口包含以下方法"><a href="#IDistributedCache接口包含以下方法" class="headerlink" title="IDistributedCache接口包含以下方法"></a>IDistributedCache接口包含以下方法</h3><ul>
<li><p>Get、GetAsync</p>
<p>  采用字符串键并以byte[]形式检索缓存项（如果在缓存中找到）。</p>
</li>
<li><p>Set、SetAsync</p>
<p>  使用字符串键向缓存添加项byte[]形式）。</p>
</li>
<li><p>Refresh、RefreshAsync</p>
<p>  根据键刷新缓存中的项，并重置其可调过期超时值（如果有）。</p>
</li>
<li><p>Remove、RemoveAsync</p>
<p>  根据键删除缓存项。</p>
</li>
</ul>
<h3 id="Redis-分布式缓存"><a href="#Redis-分布式缓存" class="headerlink" title="Redis 分布式缓存"></a>Redis 分布式缓存</h3><ol>
<li><p>安装Redis相关包，这个包是微软提供的</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">install-package</span> Microsoft.Extensions.Caching.StackExchangeRedis</span><br><span class="line">//注意以前使用的是：Microsoft.Extensions.Caching.Redis包，不过这个包<span class="number">2018</span>年后就没更新了</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.ConfigureServices</code>中注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Use Redis</span></span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt; &#123;</span><br><span class="line">    options.Configuration = <span class="string">&quot;localhost&quot;</span>;  <span class="comment">//使用本地</span></span><br><span class="line">    options.InstanceName = <span class="string">&quot;SampleInstance_&quot;</span>;  <span class="comment">//添加前缀可以区别于其他应用来的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>注入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Get&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Set&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Set</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> absoluteExpirationRelativeToNowSec = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> slidingExpirationSec = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加，注意：添加Redis后的类型是hash</span></span><br><span class="line">            <span class="comment">//默认没有过期时间</span></span><br><span class="line">            <span class="comment">//_cache.Set(&quot;id1&quot;, Encoding.Default.GetBytes(&quot;永不过期，缓存时间是：&#123;DateTime.Now.ToLongTimeString()&#125;&quot;), new DistributedCacheEntryOptions &#123; &#125;);</span></span><br><span class="line">            <span class="comment">//同样可以设置绝对过期时间与滑动过期时间</span></span><br><span class="line">            _cache.Set(</span><br><span class="line">                <span class="string">&quot;id1&quot;</span>,</span><br><span class="line">                Encoding.Default.GetBytes(<span class="string">$&quot;缓存时间是：<span class="subst">&#123;DateTime.Now.ToLongTimeString()&#125;</span>，过期时间是：<span class="subst">&#123;DateTime.Now.AddSeconds(absoluteExpirationRelativeToNowSec).ToLongTimeString()&#125;</span>&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> DistributedCacheEntryOptions</span><br><span class="line">                &#123;</span><br><span class="line">                    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(absoluteExpirationRelativeToNowSec),</span><br><span class="line">                    SlidingExpiration = TimeSpan.FromSeconds(slidingExpirationSec)</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Del&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Del</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移除</span></span><br><span class="line">        _cache.Remove(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Refresh&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Refresh</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//刷新，Get命令同样会刷新滑动过期时间</span></span><br><span class="line">        _cache.Refresh(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>访问一个缓存和数据库都不存在的key，由于该key注定获得不了数据，因此不会被写缓存，永远都会直接访问到数据库上。这种缓存永远起不了作用，直接被”穿透“到数据库的情况，被称为缓存穿透。</p>
<p> <strong>解决方案</strong>：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>当出现这种请求时，也将其缓存，其key为请求的key，value为null，但是缓存有效时间设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>某一个热点key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>加互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</li>
<li><strong>热点数据不过期</strong>。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>  缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p><strong>加互斥锁</strong>。同<a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>的。</p>
</li>
<li><p><strong>热点数据不过期</strong>。同<a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>的。</p>
</li>
<li><p><strong>错开过期时间</strong>。在基础过期时间的基础上，加上一个随机时间，防止同一时间大量数据过期现象发生。如：本来统一设置位3分钟的，变为3分钟加1-15秒的随机数。</p>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文章是基本上是基于ASP.NET Core3.1版本编写，其后续版本可能发生变化，具体使用请去<a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a>查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He">.NET 6教程，.Net Core 2022视频教程，杨中科主讲</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/359118610">缓存穿透、缓存击穿、缓存雪崩解决方案</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>Caching</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore的Filter</title>
    <url>/2022/01/+ASP.NETCore%E7%9A%84Filter/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h2><p>过滤器（Filter）是 AOP[^AOP] 思想的一种实现，让我们在执行管道（pipeline）的特定阶段（之前或之后）执行代码，管道在选择了要执行的操作之后运行。</p>
<p>下面图片显示了管道所在位置</p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-1.png" alt="aspnetcore-filter-pipeline-1.png"></p>
<p>通过使用过滤器可以实现 <strong>短路请求、缓存请求结果、日志统一记录、参数合法性验证、异常统一处理、返回值格式化</strong> 等，同时使业务代码更加简洁单纯，避免很多重复代码。</p>
<span id="more"></span>

<h2 id="5种Filter"><a href="#5种Filter" class="headerlink" title="5种Filter"></a>5种Filter</h2><h3 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h3><ul>
<li><p><strong><a href="#Authorizaion-Filter">Authorizaion Filter</a></strong> ：<strong>授权过滤器</strong></p>
<p>Authorization是五种Filter中最先运行的，用于确定是否已针对请求为用户授权。 如果请求未获授权，可以让管道短路。</p>
<p><strong>作用</strong>：主要用于实现复杂的<code>权限角色认证</code>、<code>登陆授权</code>等操作。</p>
</li>
<li><p><strong><a href="#Resource-Filter">Resource Filter</a></strong> ：<strong>资源过滤器</strong></p>
<p>OnResourceExecuting：在Authorization之后，Model Binding之前执行，对<strong>实现缓存或者对过滤管道进行短路</strong>特别有用。</p>
<p>OnResourceExecuted：在管道的其余阶段完成之后运行代码。</p>
<p><strong>作用</strong>：主要用于进行<code>资源缓存</code>、<code>防盗链</code>等操作。</p>
</li>
<li><p><strong><a href="#Exception-Filter">Exception Filter</a></strong> ：<strong>异常过滤器</strong></p>
<p>异常处理的Filter，在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。</p>
<p><strong>作用</strong>：可以进行全局的<code>异常日志收集</code>、<code>错误信息友好化处理</code>等操作。</p>
</li>
<li><p><strong><a href="#Action-Filter">Action Filter</a></strong> ：<strong>操作过滤器</strong></p>
<p>最常使用的Filter，实际上包围了整个Action。</p>
<p>OnActionExecuting：执行实际Action操作前触发，更改传递到操作中的参数。</p>
<p>OnActionExecuted：执行实际Action操作后触发，更改从操作返回的结果。</p>
<p><strong>作用</strong>：做法太多了，可以用于<code>执行操作日志</code>、<code>参数验证</code>，<code>权限控制</code>等一系列操作。</p>
</li>
<li><p><strong><a href="#Result-Filter">Result Filter</a></strong> ：<strong>结果过滤器</strong></p>
<p>在执行操作结果之前和之后立即运行代码。<strong>仅当操作方法成功执行时，它们才会运行</strong>。对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。</p>
<p>OnResultExecuting：在操作结果执行之前调用。</p>
<p>OnResultExecuted：在操作结果执行之后调用。</p>
<p><strong>作用</strong>：可以对结果进行<code>格式化</code>、<code>大小写转换</code>、<code>缓存结果</code>等一系列操作。</p>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>下图是我自制的一个比较完整的请求在<code>Filter Pipeline</code>中的流动的流程图。</p>
<p>需要特别注意的是<code>Exception Filter</code>的位置：</p>
<ul>
<li><p>在<strong>它位置之下</strong>的流程中抛出的错误才会被其捕捉处理，然后再流经<code>Resource Filter</code>的<code>OnResourceExecuted</code>方法后出去。</p>
</li>
<li><p>在<code>Exception Filter</code>之上的<code>Authorizaion Filter</code>与<code>Resource Filter</code>抛出的错误实际都不会被<code>Exception Filter</code>捕捉处理。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-2.jpg" alt="aspnetcore-filter-pipeline-2.jpg (1003×1344) (raw.githubusercontent.com)"></p>
<p>所有Filter均可通过不同的接口定义支持同步和异步的实现。根据需要执行的任务类型，选择同步或异步实现。</p>
<p>通过设置<strong>Context.Result</strong>来截断请求，可以是使Filter管道短路。</p>
<p><strong>注意：</strong>下面的例子优先使用同步方式实现。下面的例子是一个WebApi项目。</p>
<h3 id="Authorizaion-Filter"><a href="#Authorizaion-Filter" class="headerlink" title="Authorizaion Filter"></a>Authorizaion Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnAuthorizationAsync</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>AuthorizationFilterAsync</code>方法</p>
<p>下面是一个实际的鉴权例子，由我以前一个WebApi项目改造而来</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Authorization;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Controllers;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorizationFilter</span> : <span class="title">IAuthorizationFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAuthorization</span>(<span class="params">AuthorizationFilterContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;AuthorizationFilter.OnAuthorization, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否能被匿名调用</span></span><br><span class="line">            <span class="keyword">var</span> action = context.ActionDescriptor <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">var</span> allowAnonymousAttr = action.MethodInfo.GetCustomAttribute&lt;AllowAnonymousAttribute&gt;();</span><br><span class="line">            <span class="built_in">bool</span> isAllowAnonymous = allowAnonymousAttr == <span class="literal">null</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//能被匿名调用，则继续执行；</span></span><br><span class="line">            <span class="comment">//不能被匿名调用，则验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isAllowAnonymous == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息，流程不在往下走</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对异常进行处理，需要注意抛出的异常不能被Exception Filter所捕获，因此不要想着直接throw出去</span></span><br><span class="line">                context.Result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;鉴权服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;); ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;AuthorizationFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是如果在Authorizaion Filter中抛出的异常，那<strong>并不会被Exception Filter所捕获</strong></p>
<h3 id="Resource-Filter"><a href="#Resource-Filter" class="headerlink" title="Resource Filter"></a>Resource Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnResourceExecuting</code>与<code>OnResourceExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>OnResourceExecutionAsync</code>方法，注意没有<code>OnResourceExecutedAsync</code>这个方法</p>
<p>下面是简单的页面缓存例子，在<code>OnResourceExecuted</code>获得缓存，在</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourceFilter</span> : <span class="title">IResourceFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuting</span>(<span class="params">ResourceExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，有就获得缓存内的value，然后构造response再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuted</span>(<span class="params">ResourceExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，没有就保存到缓存，再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exception-Filter"><a href="#Exception-Filter" class="headerlink" title="Exception Filter"></a>Exception Filter</h3><p>同步：继承<code>IExceptionFilter</code>接口，实现<code>OnException</code>方法</p>
<p>异步：继承<code>IAsyncExceptionFilter</code>接口，实现<code>OnExceptionAsync</code>方法</p>
<p>下面例子catch了所有错误并进行处理</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExceptionFilter</span> : <span class="title">IExceptionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">ExceptionContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ExceptionFilter.OnException, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ObjectResult result;</span><br><span class="line">            <span class="keyword">var</span> isShowDevExceptionMsg = <span class="string">&quot;false&quot;</span>;</span><br><span class="line">            <span class="comment">//isShowDevExceptionMsg = configuration.GetSection(&quot;IsShowDevExceptionMsg&quot;).Value;  //由配置得到</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(isShowDevExceptionMsg) &amp;&amp; isShowDevExceptionMsg.ToLower() == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span>, devMsg = context.Exception.Message &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.StatusCode = <span class="number">500</span>;</span><br><span class="line">            context.Result = result;</span><br><span class="line">            context.ExceptionHandled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ExceptionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建FilterTestController.cs添加测试用Action</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意<code>Context.ExceptionHandled = true</code>，设置后<strong>标记异常已被处理，异常不会再抛出，后续的Exception Filter不会再触发</strong>。</p>
<h3 id="Action-Filter"><a href="#Action-Filter" class="headerlink" title="Action Filter"></a>Action Filter</h3><p>同步：继承<code>IActionFilter</code>接口，实现<code>OnActionExecuting</code>与<code>OnActionExecuted</code>方法</p>
<p>异步：继承<code>IAsyncActionFilter</code>接口，实现<code>OnActionExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//做权限校验或参数验证等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ActionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意异步的写法，<code>await next();</code>会调用<code>Action</code>或下一个<code>Action Filter</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterAsync</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnActionExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnActionExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，同步于异步是能同时使用的</p>
<p>使用Action Filter的案例：</p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=135">案例：自动启用事务的ActionFilter</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=136">案例：对请求限速的ActionFilter</a></p>
<h3 id="Result-Filter"><a href="#Result-Filter" class="headerlink" title="Result Filter"></a>Result Filter</h3><p>同步：继承<code>IResultFilter</code>接口，实现<code>OnResultExecuting</code>与<code>OnResultExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResultFilter</code>接口，实现<code>OnResultExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilter</span> : <span class="title">IResultFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuting</span>(<span class="params">ResultExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Response的Header添加信息</span></span><br><span class="line">            context.HttpContext.Response.Headers.Add(<span class="string">&quot;MoreInfo&quot;</span>, <span class="string">&quot;Just a test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuted</span>(<span class="params">ResultExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里就不能再在Header添加信息了</span></span><br><span class="line">            <span class="comment">//还可以在这里缓存结果内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResultFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步，与<code>Action Filter</code>的异步类似</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilterAsync</span> : <span class="title">IAsyncResultFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnResultExecutionAsync</span>(<span class="params">ResultExecutingContext context, ResultExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnResultExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnResultExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的注册"><a href="#Filter的注册" class="headerlink" title="Filter的注册"></a>Filter的注册</h2><p>Filter有三种注册方式<code>Action</code>、<code>Controller</code>、<code>全局</code> ，其作用域由低到高。</p>
<h3 id="Action注册"><a href="#Action注册" class="headerlink" title="Action注册"></a>Action注册</h3><p>只针对特定的Action，影响最小，适合于对特定Action进行特殊处理。</p>
<p>使用<code>[TypeFilter(Type)]</code>进行注册，如注册上面例子的ResourceFilter。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller注册"><a href="#Controller注册" class="headerlink" title="Controller注册"></a>Controller注册</h3><p>影响该Controller下的所有Action。</p>
<p>与上面<code>Action注册</code>的办法一样，通过<code>[TypeFilter(Type)]</code>进行注册。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FilterTestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>前面的例子使用的就是全局注册方式，该方式会影响到所有的进入<code>Filter Pipeline</code>的请求。</p>
<p>该注册方式能够很好的进行一些需要影响全局的处理，如：全局的异常处理、全局的日志记录</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">        <span class="comment">//下面的也可以，不过不推荐</span></span><br><span class="line">        <span class="comment">//config.Filters.Add(new ResourceFilter());</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeFilter-和-ServiceFilter-注册方式"><a href="#TypeFilter-和-ServiceFilter-注册方式" class="headerlink" title="TypeFilter 和 ServiceFilter 注册方式"></a>TypeFilter 和 ServiceFilter 注册方式</h3><p>前面的<code>Action注册</code>与<code>Controller注册</code>使用的都是<code>TypeFilter</code>的方式注册，实际还可以用<code>ServiceFilter</code>来注册，两者的异同为：</p>
<ul>
<li>ServiceFilter和TypeFilter都实现了IFilterFactory，因此都可以使用注册的Filter中构造函数中注入的对象，不需要特殊处理。</li>
<li>ServiceFilter需要对自定义的Filter进行注册，TypeFilter不需要。</li>
<li>ServiceFilter的Filter生命周期源自于您如何注册，而TypeFilter每次都会创建一个新的实例。</li>
</ul>
<p>使用<code>ServiceFilter</code>进行<code>Action注册</code>例子如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ServiceFilter(typeof(ExceptionFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddTransient&lt;ExceptionFilter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特性化"><a href="#特性化" class="headerlink" title="特性化"></a>特性化</h2><p>编写Filter时多继承Attribute类就能像普通特性一般使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Attributes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于有构造函数的，且其构造函数的参数是由DI容器注入的，则需要在已编写完成的Filter外再加一层，通过继承<code>TypeFilterAttribute</code>来实现，而<code>TypeFilterAttribute</code>实现<code>IFilterFactory</code>接口，<code>IFilterFactory</code> 公开用于创建<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifiltermetadata">IFilterMetadata</a>实例的<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory.createinstance">CreateInstance</a>方法，<code>CreateInstance</code>从服务容器 (DI) 中加载指定的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterWithDIAttribute</span> : <span class="title">TypeFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyActionFilterWithDIAttribute</span>() : <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(ActionFilterWithDI</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterWithDI</span> : <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里注入了IConfiguration</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionFilterWithDI</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="comment">//throw new Exception(&quot;ActionFilter.OnActionExecuting Exception&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilterWithDI</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的执行顺序"><a href="#Filter的执行顺序" class="headerlink" title="Filter的执行顺序"></a>Filter的执行顺序</h2><h3 id="相同类型的Filter不同注册方式的执行顺序"><a href="#相同类型的Filter不同注册方式的执行顺序" class="headerlink" title="相同类型的Filter不同注册方式的执行顺序"></a>相同类型的Filter不同注册方式的执行顺序</h3><p>首先对于同类型Filter同样注册方式的Filter，其执行顺序默认时先加的先执行。</p>
<p>而对于同类型Filter不同注册方式（action、Controller、全局）的Filter，以Aciton Filter为例其默认执行顺序如下：</p>
<ul>
<li><p>OnActionExecuting(全局)</p>
<ul>
<li><p>OnActionExecuting(Controller)</p>
<ul>
<li><p>OnActionExecuting(action)</p>
<ul>
<li>Action</li>
</ul>
</li>
<li><p>OnActionExecuted(action)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(Controller)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(全局)</p>
</li>
</ul>
<p>可以看到非常符合AOP的风格。</p>
<h3 id="改变执行顺序"><a href="#改变执行顺序" class="headerlink" title="改变执行顺序"></a>改变执行顺序</h3><p>虽然默认的执行顺序如上，但是我们是可以更改其执行顺序的，只要我们创建Filter的时候同时实现<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter">IOrderedFilter</a>接口，就能在注册时附带上排序值，数值越小优先权越高，没设置的默认值为0，默认值相等的按照上面的规则执行。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span>, <span class="title">IOrderedFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">//实现的时候IOrderedFilter需要声明一个order属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时设置Order属性，如设置-1提升其优先权</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter(Order = -1)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">ASP.NET Core Filters</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/112508518">Asp.Net Core Filter 深入浅出的那些事-AOP</a></p>
<p><a href="https://www.cnblogs.com/snaildev/p/9154669.html">ASP.NET Core 2 学习笔记（十四）Filters</a></p>
<p>[^AOP]:面向切面编程（AOP是Aspect Oriented Program的首字母缩写），在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>Filter</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NVM管理node.js版本</title>
    <url>/2022/01/+%E4%BD%BF%E7%94%A8NVM%E7%AE%A1%E7%90%86node.js%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是NVM"><a href="#什么是NVM" class="headerlink" title="什么是NVM"></a>什么是NVM</h2><p>全名<strong>node.js version management</strong>，是一个<strong>node.js的版本管理工具</strong>。通过它可以安装和切换不同版本的 nodejs。</p>
<p>其主要解决不同项目所需node.js版本不一致时管理的麻烦，就比如我弄hexo主题，不同的主题需要的nodejs版本不一致，没有这来管理，我得不停安装卸载nodejs来测试，还要修改环境变量等，十分麻烦，使用这工具就能很轻松管理。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="第一步：卸载你的NodeJs"><a href="#第一步：卸载你的NodeJs" class="headerlink" title="第一步：卸载你的NodeJs"></a>第一步：卸载你的NodeJs</h3><p>将电脑现在装的node进行卸载，最好是删除所有关于node的文件及内容</p>
<h3 id="第二步：安装NVM"><a href="#第二步：安装NVM" class="headerlink" title="第二步：安装NVM"></a>第二步：安装NVM</h3><p>通过Github服务器<a href="https://github.com/coreybutler/nvm-windows/releases">下载安装</a></p>
<p>下载完成后，按照安装操作一步一步安装就好了，很简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置</span><br><span class="line">nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。</span><br><span class="line">Source code(zip)：zip压缩的源码</span><br><span class="line">Sourc code(tar.gz)：tar.gz的源码，一般用于Linux系统</span><br></pre></td></tr></table></figure>

<p>建议下载nvm-setup.zip版本，配置我怕你不会弄弄乱了也不懂改。</p>
<p>打开zip文件，运行exe文件安装，我建议把nvm与node相关都统合在一起，以后好管理，我统一都在<code>C:\Env</code>下，NVM安装地址就填<code>C:\Env\NVM</code>，nodejs安装地址就填<code>C:\Env\nodejs</code>，安装完后你会看到<code>C:\Env</code>目录下有NVM文件夹，但是没有nodejs文件夹，这是因为前面的nodejs地址填的是以后nodejs的访问地址，现在还没有安装并使用nodejs自然就没有。</p>
<h3 id="第三步：测试nvm是否安装成功"><a href="#第三步：测试nvm是否安装成功" class="headerlink" title="第三步：测试nvm是否安装成功"></a>第三步：测试nvm是否安装成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm -v</span><br><span class="line">//version 1.1.6  出现版本号，说明安装成功，接下来就可以进行下面的操作</span><br></pre></td></tr></table></figure>

<h3 id="第四步：安装并控制node版本"><a href="#第四步：安装并控制node版本" class="headerlink" title="第四步：安装并控制node版本"></a>第四步：安装并控制node版本</h3><p>前面完成后，接下来就可以安装并随意切换我们的node版本号了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list available  // 首先可以通过命令来查询我们可以安装的node版本</span><br><span class="line">nvm install 10.5.0  // 安装指定的版本的nodejs</span><br><span class="line">nvm <span class="built_in">ls</span>   // 查看目前已经安装的版本</span><br><span class="line">nvm use 10.5.0  // 使用指定版本的nodejs，需要权限较高，windows下需要管理员权限</span><br></pre></td></tr></table></figure>

<p>可以通过<code>nvm install</code>命令安装多个版本的nodejs，然后通过<code>nvm use</code>命令来切换要是用的版本号。</p>
<p>通过切换版本号后，可以通过<code>node -v</code>命令来检测是否使用成功。</p>
<h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>由于国外的镜像源下载慢，可以使用命令更改为Taobao的源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<h2 id="NVM常用命令"><a href="#NVM常用命令" class="headerlink" title="NVM常用命令"></a>NVM常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm off                     // 禁用node.js版本管理(不卸载任何东西)</span><br><span class="line">nvm on                      // 启用node.js版本管理</span><br><span class="line">nvm install &lt;version&gt;       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0</span><br><span class="line">nvm uninstall &lt;version&gt;     // 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用</span><br><span class="line">nvm <span class="built_in">ls</span>                      // 显示所有已安装的node.js版本</span><br><span class="line">nvm list available          // 显示可以安装的所有node.js的版本</span><br><span class="line">nvm use &lt;version&gt;           // 切换到使用指定的nodejs版本</span><br><span class="line">nvm v                       // 显示nvm版本</span><br><span class="line">nvm install stable          // 安装最新稳定版</span><br></pre></td></tr></table></figure>

<h2 id="可能遇到问题解决"><a href="#可能遇到问题解决" class="headerlink" title="可能遇到问题解决"></a>可能遇到问题解决</h2><ul>
<li><p>windows 上安装 nvm 后选择 node 版本出现 exit status 1…</p>
<p>问题：nvm install x.x.x 可以安装成功，但无法切换和使用，报错 exit status 1</p>
<p>原因1：把 nvm 安装到了有空格的路径上（D:\Program Files），导致切换失败</p>
<p>解决1：把 nvm 卸载重装到没有空格的路径上（例如：D:\nvm），即可解决问题</p>
<p>原因2：Cmd命令权限不足</p>
<p>解决2：使用 <strong>以管理员身份运行</strong> 运行<code>Cmd</code>程序，然后再运行<code>nvm</code>命令</p>
</li>
<li><p>nvm 在 CMD 中不生效</p>
<p>报错：nvm : 无法将 nvm 项识别为 cmdlet、函数、脚本文件或可运行程序的名称。</p>
<p>意思就是<code>nvm</code>还不是个命令，说明没有配置成功。</p>
<p>原因：当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启<code>cmd</code>控制台后会生效。</p>
</li>
<li><p>npm Download failed</p>
<p>有时候安装 node 安装成功之后，会去安装 npm 有时候就会报错 npm 拒绝啥的，具体报错没有记录</p>
<p>解决：使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）</p>
</li>
<li><p>node 版本安装成功，但是使用时还是之前的版本</p>
<p>如之前安装过node版本 10.15.0，没有卸载，直接安装的 nvm，并用 nvm 安装了 14.18.1 的 node。如下切换成 14.18.1 版本也正常，但是查看 node -v 却还是之前的版本。</p>
<p>解决：<strong>在安装 NVM for Windows 之前，您需要卸载任何现有版本的 node.js，还需要删除任何现有nodejs安装目录</strong>。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/goloving/p/15401739.html">浅析nvm介绍、安装与使用以及遇到的问题解决</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>NVM</tag>
        <tag>npm</tag>
        <tag>nodejs</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>快速打开关闭sqlserver相关服务</title>
    <url>/2022/01/+%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E5%85%B3%E9%97%ADsqlserver%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL Server安装后默认是一直随系统启动的，对于服务器当然没问题，但是对于个人开发而言，确实是不希望在不需要时一直运行相关SQL Server的服务。毕竟个人电脑性能有限，还是希望软件能够要用的才打开，不需要时能够释放占用的性能。</p>
<p>于是就有了这篇文章，提供一个脚本，需要时开启SQL Server相关服务，不需要是关闭SQL Server相关服务。</p>
<span id="more"></span>

<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>复制下面代码到文本文件，然后保存后改文件后缀名为.bat，然后<strong>以管理员身份运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::脚本目的：需要用sqlserver快速开启相关服务，不需要时快速关闭相关服务已节省资源</span><br><span class="line">::测试SQL版本：SQL Server 2008 R2</span><br><span class="line"></span><br><span class="line">@ECHO OFF&amp;CLS&amp;color 0a</span><br><span class="line">:HeadStart</span><br><span class="line">ECHO=</span><br><span class="line">ECHO= =-=-=-=-=-=选择开启或关闭=-=-=-=-=-=</span><br><span class="line">ECHO= 1、开启sqlserver的6个相关服务</span><br><span class="line">ECHO= 2、关闭sqlserver的6个相关服务</span><br><span class="line">ECHO= 9、退出</span><br><span class="line">ECHO= =-=-=-=-==-=-=-=-==-=-=-=-==-=-=-=</span><br><span class="line">ECHO=</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>/p ID= 请选择：</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;1&quot;</span> (</span><br><span class="line">	::数据库引擎</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlserver***</span><br><span class="line">	net start mssqlserver</span><br><span class="line">	::远程MSSMS管理</span><br><span class="line">	<span class="built_in">echo</span>=***打开sqlserveragent***</span><br><span class="line">	net start sqlserveragent</span><br><span class="line">	::全文索引程序，一般mssqlserver服务启动后就会级联开启该服务</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlfdlauncher***</span><br><span class="line">	net start mssqlfdlauncher</span><br><span class="line">	::分布式事务</span><br><span class="line">	<span class="built_in">echo</span>=***打开msdtc***</span><br><span class="line">	net start msdtc</span><br><span class="line">	::备份还原数据库用的</span><br><span class="line">	<span class="built_in">echo</span>=***打开SQLWriter***</span><br><span class="line">	net start SQLWriter</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***需要时候自己添加命令net start MSSQLServerADHelper100***</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;2&quot;</span> (</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***关闭MSSQLServerADHelper100***</span><br><span class="line">	net stop MSSQLServerADHelper100</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlfdlauncher***</span><br><span class="line">	net stop mssqlfdlauncher</span><br><span class="line">	<span class="built_in">echo</span>=***关闭msdtc***</span><br><span class="line">	net stop msdtc</span><br><span class="line">	<span class="built_in">echo</span>=***关闭SQLWriter***</span><br><span class="line">	net stop SQLWriter</span><br><span class="line">	<span class="built_in">echo</span>=***关闭sqlserveragent***</span><br><span class="line">	net stop sqlserveragent</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlserver***</span><br><span class="line">	net stop mssqlserver /y</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;9&quot;</span> <span class="built_in">exit</span></span><br><span class="line">pause</span><br><span class="line">Goto HeadStart</span><br></pre></td></tr></table></figure>

<h2 id="相关的6个服务"><a href="#相关的6个服务" class="headerlink" title="相关的6个服务"></a>相关的6个服务</h2><ul>
<li><p>服务名：mssqlserver</p>
<p>显示名：SQL Server(MSSQLSERVER)服务，SQLServer服务实例，主要服务，只有开启了这个你才能使用Microsoft SQLServer Management Studio连接该数据库实例，开启后会级联开启mssqlfdlauncher服务。</p>
</li>
<li><p>服务名：sqlserveragent</p>
<p>显示名：SQL Server 代理 (MSSQLSERVER)</p>
<p>说明：执行作业、监视 SQL Server、激发警报，以及允许自动执行某些管理任务。</p>
</li>
<li><p>服务名：mssqlfdlauncher</p>
<p>显示名：SQL Full-text Filter Daemon Launcher (MSSQLSERVER)</p>
<p>说明：用于启动全文筛选器后台程序进程的服务，该进程将为 SQL Server 全文搜索执行文档筛选和断字。禁用此服务将使 SQL Server 的全文搜索功能不可用。</p>
</li>
<li><p>服务名：msdtc</p>
<p>显示名：Distributed Transaction Coordinator</p>
<p>说明：协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。当一个事务中涉及多个数据源（比如两台sqlserver）服务器，需要MSDTC的协调处理，一般单机可关闭该服务。</p>
</li>
<li><p>服务名：SQLWriter</p>
<p>显示名：SQL Server VSS Writer</p>
<p>说明：sqlwriter是Microsoft SQL Server的编写器服务，允许备份和还原应用程序，以便在Volume Shadow Copy Service（VSS）框架中进行操作，服务器上的所有SQL实例只有一个SQL编写器服务。</p>
</li>
<li><p>服务名：MSSQLServerADHelper100</p>
<p>显示名：SQL Active Directory Helper 服务</p>
</li>
<li><p>服务名：SQLBrowser</p>
<p>显示名：SQL Server Browser</p>
<p>说明：如果一个物理服务器上面有多个SQL Server实例，那么为了确保客户端能访问到正确的实例，所以自SQL Server 2005提供了一个新的Browser服务。如果一台计算机上只有一个实例，且配置为静态端口，则无需启动Browser服务；反之则需要启动。</p>
</li>
</ul>
<h2 id="有关MSSQLServerADHelper启动问题"><a href="#有关MSSQLServerADHelper启动问题" class="headerlink" title="有关MSSQLServerADHelper启动问题"></a>有关MSSQLServerADHelper启动问题</h2><blockquote>
<p>I want to inform that MSSQLServerADHelper service is dynamically started by an instance of SQL Server or Analysis Manager when needed, and is stopped as soon as it has completed its work, we don’t need to start it manually. Additionally, let’s change the service startup account as localsystem account and check whether the error occurs again.</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
        <category>使用技巧</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
        <tag>数据库</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
</search>
