<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASP.NETCore使用Swagger</title>
    <url>/index.html/2022/01/06/+ASP.NETCore%E4%BD%BF%E7%94%A8Swagger/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a>什么是swagger</h2><p><a href="https://swagger.io/">swagger</a>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。</p>
<p>简单来讲，使用swagger能够自动生成友好的在线接口文档，并且支持接口测试，其好处：</p>
<ul>
<li>对后端人员：减少了编写接口后还要花费时间同步更新接口文档，且与前端沟通的时间成本。</li>
<li>对前端人员：能够直观的快速的看到接口，并且进行在线测试，方便了调试调用接口，不用因接口问题频繁与后端沟通。</li>
</ul>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>框架.net3.1默认没有swagger，需要自己弄，以下简单写步骤</p>
<ol>
<li><p>nuget安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Swashbuckle.AspNetCore</span><br></pre></td></tr></table></figure></li>
<li><p>Startup.cs文件引入命名空间</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Swashbuckle.AspNetCore.Swagger;</span><br><span class="line"><span class="keyword">using</span> Microsoft.OpenApi.Models;</span><br></pre></td></tr></table></figure></li>
<li><p>将 Swagger 生成器添加到 <code>Startup.ConfigureServices</code> 方法中的服务集合中</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>Startup.Configure</code> 方法中，启用中间件为生成的 JSON 文档和 Swagger UI 提供服务</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>此时启动项目就可通过<code>http://localhost:&lt;port&gt;/swagger</code>地址访问Swagger UI浏览API文档。</p>
<p>   也可通过<code>http://localhost:&lt;port&gt;/swagger/v1/swagger.json</code>地址访问生成的描述终结点的json文档。</p>
</li>
<li><p>如果要想通过<code>http://localhost:&lt;port&gt;/</code>就访问Swagger UI，修改启用中间件SwaggerUI的方法<code>UseSwaggerUI</code>，把<code>RoutePrefix</code> 属性设置为空字符串。</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="添加版本控制"><a href="#添加版本控制" class="headerlink" title="添加版本控制"></a>添加版本控制</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>添加API枚举类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 版本控制</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ApiVersion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v1版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V1 = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v2版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V2 = <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历版本信息</span></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerDoc(version, <span class="keyword">new</span> OpenApiInfo</span><br><span class="line">        &#123;</span><br><span class="line">            Version = version, <span class="comment">//版本号</span></span><br><span class="line">            Title = <span class="string">$&quot;My API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//标题</span></span><br><span class="line">            Description = <span class="string">$&quot;My ASP.NET Core Web API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//描述</span></span><br><span class="line">            <span class="comment">//上面三项最后设置，下面的三项可以不用</span></span><br><span class="line">            TermsOfService = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/terms&quot;</span>), <span class="comment">//服务条款</span></span><br><span class="line">            Contact = <span class="keyword">new</span> OpenApiContact</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Singo&quot;</span>, <span class="comment">//联系人</span></span><br><span class="line">                Email = <span class="built_in">string</span>.Empty,  <span class="comment">//邮箱</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://github.com/hushitong&quot;</span>),<span class="comment">//网站</span></span><br><span class="line">            &#125;,</span><br><span class="line">            License = <span class="keyword">new</span> OpenApiLicense</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Use under LICX&quot;</span>, <span class="comment">//协议</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/license&quot;</span>), <span class="comment">//协议地址</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.Configure</code> 里启用中间件的设置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//描述终结点的json文档</span></span><br><span class="line">        c.SwaggerEndpoint(<span class="string">$&quot;/swagger/<span class="subst">&#123;version&#125;</span>/swagger.json&quot;</span>, version);</span><br><span class="line">        <span class="comment">//设置为none可折叠所有方法</span></span><br><span class="line">        c.DocExpansion(Swashbuckle.AspNetCore.SwaggerUI.DocExpansion.None);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>然后就是使用ApiExplorerSettingsAttribute标注各个版本Controller，然后修改路由信息</p>
<p>原来的标注为</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V1))</span>]</span><br></pre></td></tr></table></figure>

<p>后来的根据需要标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V2))</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>启动后就可以通过右上角的下拉框选择需要的版本进行测试了</p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有关版本控制实际有很多办法，如：可以查看<a href="https://www.cnblogs.com/Leo_wl/p/7508650.html">Net Core WebApi几种版本控制对比</a></p>
<h2 id="添加JWT支持"><a href="#添加JWT支持" class="headerlink" title="添加JWT支持"></a>添加JWT支持</h2><ol>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 添加JWT支持</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">&quot;Bearer&quot;</span>, <span class="keyword">new</span> OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = <span class="string">&quot;在下框中输入请求头中需要添加Jwt授权Token：Bearer Token&quot;</span>,</span><br><span class="line">        Name = <span class="string">&quot;Authorization&quot;</span>, <span class="comment">//设置其key名，请求时会添加上，默认使用Authorization名</span></span><br><span class="line">        In = ParameterLocation.Header, <span class="comment">//在请求头添加JWT Token</span></span><br><span class="line">        Type = SecuritySchemeType.ApiKey,</span><br><span class="line">        BearerFormat = <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">        Scheme = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    c.AddSecurityRequirement(<span class="keyword">new</span> OpenApiSecurityRequirement</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">            &#123;</span><br><span class="line">                Reference = <span class="keyword">new</span> OpenApiReference &#123;</span><br><span class="line">                    Type = ReferenceType.SecurityScheme,</span><br><span class="line">                    Id = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>运行进入SeaggerUI页面，可以看到在页面右上角多了一个<code>Authorize</code>按钮，点击在value框可以填入<code>bear &lt;your jwt string&gt;</code>，以后请求头都会带上<code>Authorization: bear &lt;your jwt string&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/SwaggerWithJWT.png" alt="SwaggerWithJWT"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>文档</tag>
        <tag>Swagger</tag>
        <tag>版本控制</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore的Filter</title>
    <url>/index.html/2022/01/30/ASP.NETCore%E7%9A%84Filter/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h2><p>过滤器（Filter）是 AOP[^AOP]思想的一种实现，让我们在执行管道（pipeline）的特定阶段（之前或之后）执行代码，管道在选择了要执行的操作之后运行。</p>
<p>下面图片显示了管道所在位置</p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-1.png" alt="aspnetcore-filter-pipeline-1.png"></p>
<p>通过使用过滤器可以实现 <strong>短路请求、缓存请求结果、日志统一记录、参数合法性验证、异常统一处理、返回值格式化</strong> 等，同时使业务代码更加简洁单纯，避免很多重复代码。</p>
<span id="more"></span>

<h2 id="5种Filter"><a href="#5种Filter" class="headerlink" title="5种Filter"></a>5种Filter</h2><ul>
<li><p><strong>Authorizaion Filter</strong>：<strong>授权过滤器</strong></p>
<p>Authorization是五种Filter中最先运行的，用于确定是否已针对请求为用户授权。 如果请求未获授权，可以让管道短路。</p>
<p><strong>作用</strong>：主要用于实现复杂的<code>权限角色认证</code>、<code>登陆授权</code>等操作。</p>
</li>
<li><p><strong>Resource Filter</strong>：<strong>资源过滤器</strong></p>
<p>OnResourceExecuting：在Authorization之后，Model Binding之前执行，对<strong>实现缓存或者对过滤管道进行短路</strong>特别有用。</p>
<p>OnResourceExecuted：在管道的其余阶段完成之后运行代码。</p>
<p><strong>作用</strong>：主要用于进行<code>资源缓存</code>、<code>防盗链</code>等操作。</p>
</li>
<li><p><strong>Exception Filter</strong>：<strong>异常过滤器</strong></p>
<p>异常处理的Filter，在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。</p>
<p><strong>作用</strong>：可以进行全局的<code>异常日志收集</code>、<code>错误信息友好化处理</code>等操作。</p>
</li>
<li><p><strong>Action Filter</strong>：<strong>操作过滤器</strong></p>
<p>最常使用的Filter，实际上包围了整个Action。</p>
<p>OnActionExecuting：执行实际Action操作前触发，更改传递到操作中的参数。</p>
<p>OnActionExecuted：执行实际Action操作后触发，更改从操作返回的结果。</p>
<p><strong>作用</strong>：做法太多了，可以用于<code>执行操作日志</code>、<code>参数验证</code>，<code>权限控制</code>等一系列操作。</p>
</li>
<li><p><strong>Result Filter</strong>：<strong>结果过滤器</strong></p>
<p>在执行操作结果之前和之后立即运行代码。<strong>仅当操作方法成功执行时，它们才会运行</strong>。对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。</p>
<p>OnResultExecuting：在操作结果执行之前调用。</p>
<p>OnResultExecuted：在操作结果执行之后调用。</p>
<p><strong>作用</strong>：可以对结果进行<code>格式化</code>、<code>大小写转换</code>、<code>缓存结果</code>等一系列操作。</p>
</li>
</ul>
<p>下图是我自制的一个比较完整的请求在<code>Filter Pipeline</code>中的流动的流程图。</p>
<p>需要特别注意的是<code>Exception Filter</code>的位置：</p>
<ul>
<li><p>在<strong>它位置之下</strong>的流程中抛出的错误才会被其捕捉处理，然后再流经<code>Resource Filter</code>的<code>OnResourceExecuted</code>方法后出去。</p>
</li>
<li><p>在<code>Exception Filter</code>之上的<code>Authorizaion Filter</code>与<code>Resource Filter</code>抛出的错误实际都不会被<code>Exception Filter</code>捕捉处理。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-2.jpg" alt="aspnetcore-filter-pipeline-2.jpg (1003×1344) (raw.githubusercontent.com)"></p>
<p>所有Filter均可通过不同的接口定义支持同步和异步的实现。根据需要执行的任务类型，选择同步或异步实现。</p>
<p>通过设置<strong>Context.Result</strong>来截断请求，可以是使Filter管道短路。</p>
<p><strong>注意：</strong>下面的例子优先使用同步方式实现。下面的例子是一个WebApi项目。</p>
<h3 id="Authorizaion-Filter"><a href="#Authorizaion-Filter" class="headerlink" title="Authorizaion Filter"></a>Authorizaion Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnAuthorizationAsync</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>AuthorizationFilterAsync</code>方法</p>
<p>下面是一个实际的鉴权例子，由我以前一个WebApi项目改造而来</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Authorization;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Controllers;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorizationFilter</span> : <span class="title">IAuthorizationFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAuthorization</span>(<span class="params">AuthorizationFilterContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;AuthorizationFilter.OnAuthorization, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否能被匿名调用</span></span><br><span class="line">            <span class="keyword">var</span> action = context.ActionDescriptor <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">var</span> allowAnonymousAttr = action.MethodInfo.GetCustomAttribute&lt;AllowAnonymousAttribute&gt;();</span><br><span class="line">            <span class="built_in">bool</span> isAllowAnonymous = allowAnonymousAttr == <span class="literal">null</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//能被匿名调用，则继续执行；</span></span><br><span class="line">            <span class="comment">//不能被匿名调用，则验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isAllowAnonymous == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息，流程不在往下走</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对异常进行处理，需要注意抛出的异常不能被Exception Filter所捕获，因此不要想着直接throw出去</span></span><br><span class="line">                context.Result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;鉴权服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;); ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;AuthorizationFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是如果在Authorizaion Filter中抛出的异常，那<strong>并不会被Exception Filter所捕获</strong></p>
<h3 id="Resource-Filter"><a href="#Resource-Filter" class="headerlink" title="Resource Filter"></a>Resource Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnResourceExecuting</code>与<code>OnResourceExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>OnResourceExecutionAsync</code>方法，注意没有<code>OnResourceExecutedAsync</code>这个方法</p>
<p>下面是简单的页面缓存例子，在<code>OnResourceExecuted</code>获得缓存，在</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourceFilter</span> : <span class="title">IResourceFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuting</span>(<span class="params">ResourceExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，有就获得缓存内的value，然后构造response再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuted</span>(<span class="params">ResourceExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，没有就保存到缓存，再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exception-Filter"><a href="#Exception-Filter" class="headerlink" title="Exception Filter"></a>Exception Filter</h3><p>同步：继承<code>IExceptionFilter</code>接口，实现<code>OnException</code>方法</p>
<p>异步：继承<code>IAsyncExceptionFilter</code>接口，实现<code>OnExceptionAsync</code>方法</p>
<p>下面例子catch了所有错误并进行处理</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExceptionFilter</span> : <span class="title">IExceptionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">ExceptionContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ExceptionFilter.OnException, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ObjectResult result;</span><br><span class="line">            <span class="keyword">var</span> isShowDevExceptionMsg = <span class="string">&quot;false&quot;</span>;</span><br><span class="line">            <span class="comment">//isShowDevExceptionMsg = configuration.GetSection(&quot;IsShowDevExceptionMsg&quot;).Value;  //由配置得到</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(isShowDevExceptionMsg) &amp;&amp; isShowDevExceptionMsg.ToLower() == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span>, devMsg = context.Exception.Message &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.StatusCode = <span class="number">500</span>;</span><br><span class="line">            context.Result = result;</span><br><span class="line">            context.ExceptionHandled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ExceptionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建FilterTestController.cs添加测试用Action</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意<code>Context.ExceptionHandled = true</code>，设置后<strong>标记异常已被处理，异常不会再抛出，后续的Exception Filter不会再触发</strong>。</p>
<h3 id="Action-Filter"><a href="#Action-Filter" class="headerlink" title="Action Filter"></a>Action Filter</h3><p>同步：继承<code>IActionFilter</code>接口，实现<code>OnActionExecuting</code>与<code>OnActionExecuted</code>方法</p>
<p>异步：继承<code>IAsyncActionFilter</code>接口，实现<code>OnActionExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//做权限校验或参数验证等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ActionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意异步的写法，<code>await next();</code>会调用<code>Action</code>或下一个<code>Action Filter</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterAsync</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnActionExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnActionExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，同步于异步是能同时使用的</p>
<p>使用Action Filter的案例：</p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=135">案例：自动启用事务的ActionFilter</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=136">案例：对请求限速的ActionFilter</a></p>
<h3 id="Result-Filter"><a href="#Result-Filter" class="headerlink" title="Result Filter"></a>Result Filter</h3><p>同步：继承<code>IResultFilter</code>接口，实现<code>OnResultExecuting</code>与<code>OnResultExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResultFilter</code>接口，实现<code>OnResultExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilter</span> : <span class="title">IResultFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuting</span>(<span class="params">ResultExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Response的Header添加信息</span></span><br><span class="line">            context.HttpContext.Response.Headers.Add(<span class="string">&quot;MoreInfo&quot;</span>, <span class="string">&quot;Just a test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuted</span>(<span class="params">ResultExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里就不能再在Header添加信息了</span></span><br><span class="line">            <span class="comment">//还可以在这里缓存结果内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResultFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步，与<code>Action Filter</code>的异步类似</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilterAsync</span> : <span class="title">IAsyncResultFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnResultExecutionAsync</span>(<span class="params">ResultExecutingContext context, ResultExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnResultExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnResultExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的注册"><a href="#Filter的注册" class="headerlink" title="Filter的注册"></a>Filter的注册</h2><p>Filter有三种注册方式<code>Action</code>、<code>Controller</code>、<code>全局</code> ，其作用域由低到高。</p>
<h3 id="Action注册"><a href="#Action注册" class="headerlink" title="Action注册"></a>Action注册</h3><p>只针对特定的Action，影响最小，适合于对特定Action进行特殊处理。</p>
<p>使用<code>[TypeFilter(Type)]</code>进行注册，如注册上面例子的ResourceFilter。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller注册"><a href="#Controller注册" class="headerlink" title="Controller注册"></a>Controller注册</h3><p>影响该Controller下的所有Action。</p>
<p>与上面<code>Action注册</code>的办法一样，通过<code>[TypeFilter(Type)]</code>进行注册。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FilterTestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>前面的例子使用的就是全局注册方式，该方式会影响到所有的进入<code>Filter Pipeline</code>的请求。</p>
<p>该注册方式能够很好的进行一些需要影响全局的处理，如：全局的异常处理、全局的日志记录</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">        <span class="comment">//下面的也可以，不过不推荐</span></span><br><span class="line">        <span class="comment">//config.Filters.Add(new ResourceFilter());</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeFilter-和-ServiceFilter-注册方式"><a href="#TypeFilter-和-ServiceFilter-注册方式" class="headerlink" title="TypeFilter 和 ServiceFilter 注册方式"></a>TypeFilter 和 ServiceFilter 注册方式</h3><p>前面的<code>Action注册</code>与<code>Controller注册</code>使用的都是<code>TypeFilter</code>的方式注册，实际还可以用<code>ServiceFilter</code>来注册，两者的异同为：</p>
<ul>
<li>ServiceFilter和TypeFilter都实现了IFilterFactory，因此都可以使用注册的Filter中构造函数中注入的对象，不需要特殊处理。</li>
<li>ServiceFilter需要对自定义的Filter进行注册，TypeFilter不需要。</li>
<li>ServiceFilter的Filter生命周期源自于您如何注册，而TypeFilter每次都会创建一个新的实例。</li>
</ul>
<p>使用<code>ServiceFilter</code>进行<code>Action注册</code>例子如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ServiceFilter(typeof(ExceptionFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddTransient&lt;ExceptionFilter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特性化"><a href="#特性化" class="headerlink" title="特性化"></a>特性化</h2><p>编写Filter时多继承Attribute类就能像普通特性一般使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Attributes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于有构造函数的，且其构造函数的参数是由DI容器注入的，则需要在已编写完成的Filter外再加一层，通过继承<code>TypeFilterAttribute</code>来实现，而<code>TypeFilterAttribute</code>实现<code>IFilterFactory</code>接口，<code>IFilterFactory</code> 公开用于创建<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifiltermetadata">IFilterMetadata</a>实例的<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory.createinstance">CreateInstance</a>方法，<code>CreateInstance</code>从服务容器 (DI) 中加载指定的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterWithDIAttribute</span> : <span class="title">TypeFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyActionFilterWithDIAttribute</span>() : <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(ActionFilterWithDI</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterWithDI</span> : <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里注入了IConfiguration</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionFilterWithDI</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="comment">//throw new Exception(&quot;ActionFilter.OnActionExecuting Exception&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilterWithDI</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的执行顺序"><a href="#Filter的执行顺序" class="headerlink" title="Filter的执行顺序"></a>Filter的执行顺序</h2><h3 id="相同类型的Filter不同注册方式的执行顺序"><a href="#相同类型的Filter不同注册方式的执行顺序" class="headerlink" title="相同类型的Filter不同注册方式的执行顺序"></a>相同类型的Filter不同注册方式的执行顺序</h3><p>首先对于同类型Filter同样注册方式的Filter，其执行顺序默认时先加的先执行。</p>
<p>而对于同类型Filter不同注册方式（action、Controller、全局）的Filter，以Aciton Filter为例其默认执行顺序如下：</p>
<ul>
<li><p>OnActionExecuting(全局)</p>
<ul>
<li><p>OnActionExecuting(Controller)</p>
<ul>
<li><p>OnActionExecuting(action)</p>
<ul>
<li>Action</li>
</ul>
</li>
<li><p>OnActionExecuted(action)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(Controller)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(全局)</p>
</li>
</ul>
<p>可以看到非常符合AOP的风格。</p>
<h3 id="改变执行顺序"><a href="#改变执行顺序" class="headerlink" title="改变执行顺序"></a>改变执行顺序</h3><p>虽然默认的执行顺序如上，但是我们是可以更改其执行顺序的，只要我们创建Filter的时候同时实现<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter">IOrderedFilter</a>接口，就能在注册时附带上排序值，数值越小优先权越高，没设置的默认值为0，默认值相等的按照上面的规则执行。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span>, <span class="title">IOrderedFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">//实现的时候IOrderedFilter需要声明一个order属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时设置Order属性，如设置-1提升其优先权</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter(Order = -1)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">ASP.NET Core Filters</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/112508518">Asp.Net Core Filter 深入浅出的那些事-AOP</a></p>
<p><a href="https://www.cnblogs.com/snaildev/p/9154669.html">ASP.NET Core 2 学习笔记（十四）Filters</a></p>
<p>[^AOP]:面向切面编程（AOP是Aspect Oriented Program的首字母缩写），在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>Filter</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>快速打开关闭sqlserver相关服务</title>
    <url>/index.html/2021/12/30/%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E5%85%B3%E9%97%ADsqlserver%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL Server安装后默认是一直随系统启动的，对于服务器当然没问题，但是对于个人开发而言，确实是不希望在不需要时一直运行相关SQL Server的服务。毕竟个人电脑性能有限，还是希望软件能够要用的才打开，不需要时能够释放占用的性能。</p>
<p>于是就有了这篇文章，提供一个脚本，需要时开启SQL Server相关服务，不需要是关闭SQL Server相关服务。</p>
<span id="more"></span>

<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>复制下面代码到文本文件，然后保存后改文件后缀名为.bat，然后<strong>以管理员身份运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::脚本目的：需要用sqlserver快速开启相关服务，不需要时快速关闭相关服务已节省资源</span><br><span class="line">::测试SQL版本：SQL Server 2008 R2</span><br><span class="line"></span><br><span class="line">@ECHO OFF&amp;CLS&amp;color 0a</span><br><span class="line">:HeadStart</span><br><span class="line">ECHO=</span><br><span class="line">ECHO= =-=-=-=-=-=选择开启或关闭=-=-=-=-=-=</span><br><span class="line">ECHO= 1、开启sqlserver的6个相关服务</span><br><span class="line">ECHO= 2、关闭sqlserver的6个相关服务</span><br><span class="line">ECHO= 9、退出</span><br><span class="line">ECHO= =-=-=-=-==-=-=-=-==-=-=-=-==-=-=-=</span><br><span class="line">ECHO=</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>/p ID= 请选择：</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;1&quot;</span> (</span><br><span class="line">	::数据库引擎</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlserver***</span><br><span class="line">	net start mssqlserver</span><br><span class="line">	::远程MSSMS管理</span><br><span class="line">	<span class="built_in">echo</span>=***打开sqlserveragent***</span><br><span class="line">	net start sqlserveragent</span><br><span class="line">	::全文索引程序，一般mssqlserver服务启动后就会级联开启该服务</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlfdlauncher***</span><br><span class="line">	net start mssqlfdlauncher</span><br><span class="line">	::分布式事务</span><br><span class="line">	<span class="built_in">echo</span>=***打开msdtc***</span><br><span class="line">	net start msdtc</span><br><span class="line">	::备份还原数据库用的</span><br><span class="line">	<span class="built_in">echo</span>=***打开SQLWriter***</span><br><span class="line">	net start SQLWriter</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***需要时候自己添加命令net start MSSQLServerADHelper100***</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;2&quot;</span> (</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***关闭MSSQLServerADHelper100***</span><br><span class="line">	net stop MSSQLServerADHelper100</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlfdlauncher***</span><br><span class="line">	net stop mssqlfdlauncher</span><br><span class="line">	<span class="built_in">echo</span>=***关闭msdtc***</span><br><span class="line">	net stop msdtc</span><br><span class="line">	<span class="built_in">echo</span>=***关闭SQLWriter***</span><br><span class="line">	net stop SQLWriter</span><br><span class="line">	<span class="built_in">echo</span>=***关闭sqlserveragent***</span><br><span class="line">	net stop sqlserveragent</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlserver***</span><br><span class="line">	net stop mssqlserver /y</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;9&quot;</span> <span class="built_in">exit</span></span><br><span class="line">pause</span><br><span class="line">Goto HeadStart</span><br></pre></td></tr></table></figure>

<h2 id="相关的6个服务"><a href="#相关的6个服务" class="headerlink" title="相关的6个服务"></a>相关的6个服务</h2><ul>
<li><p>服务名：mssqlserver</p>
<p>显示名：SQL Server(MSSQLSERVER)服务，SQLServer服务实例，主要服务，只有开启了这个你才能使用Microsoft SQLServer Management Studio连接该数据库实例，开启后会级联开启mssqlfdlauncher服务。</p>
</li>
<li><p>服务名：sqlserveragent</p>
<p>显示名：SQL Server 代理 (MSSQLSERVER)</p>
<p>说明：执行作业、监视 SQL Server、激发警报，以及允许自动执行某些管理任务。</p>
</li>
<li><p>服务名：mssqlfdlauncher</p>
<p>显示名：SQL Full-text Filter Daemon Launcher (MSSQLSERVER)</p>
<p>说明：用于启动全文筛选器后台程序进程的服务，该进程将为 SQL Server 全文搜索执行文档筛选和断字。禁用此服务将使 SQL Server 的全文搜索功能不可用。</p>
</li>
<li><p>服务名：msdtc</p>
<p>显示名：Distributed Transaction Coordinator</p>
<p>说明：协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。当一个事务中涉及多个数据源（比如两台sqlserver）服务器，需要MSDTC的协调处理，一般单机可关闭该服务。</p>
</li>
<li><p>服务名：SQLWriter</p>
<p>显示名：SQL Server VSS Writer</p>
<p>说明：sqlwriter是Microsoft SQL Server的编写器服务，允许备份和还原应用程序，以便在Volume Shadow Copy Service（VSS）框架中进行操作，服务器上的所有SQL实例只有一个SQL编写器服务。</p>
</li>
<li><p>服务名：MSSQLServerADHelper100</p>
<p>显示名：SQL Active Directory Helper 服务</p>
</li>
<li><p>服务名：SQLBrowser</p>
<p>显示名：SQL Server Browser</p>
<p>说明：如果一个物理服务器上面有多个SQL Server实例，那么为了确保客户端能访问到正确的实例，所以自SQL Server 2005提供了一个新的Browser服务。如果一台计算机上只有一个实例，且配置为静态端口，则无需启动Browser服务；反之则需要启动。</p>
</li>
</ul>
<h2 id="有关MSSQLServerADHelper启动问题"><a href="#有关MSSQLServerADHelper启动问题" class="headerlink" title="有关MSSQLServerADHelper启动问题"></a>有关MSSQLServerADHelper启动问题</h2><blockquote>
<p>I want to inform that MSSQLServerADHelper service is dynamically started by an instance of SQL Server or Analysis Manager when needed, and is stopped as soon as it has completed its work, we don’t need to start it manually. Additionally, let’s change the service startup account as localsystem account and check whether the error occurs again.</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
        <category>使用技巧</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
        <tag>数据库</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core缓存</title>
    <url>/index.html/2022/01/30/ASP.NETCore%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Caching通过减少生成内容所需的工作，显著提高应用的性能和可伸缩性。 Caching最适用于不经常更改 <strong>且生成成本</strong> 高的数据。 Caching可比从源返回快得多的数据副本。</p>
<p>ASP.NET Core支持多个不同的缓存</p>
<ul>
<li>客户端缓存 Cache-control</li>
<li>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></li>
<li>内存缓存  <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory">In-MemoryCache</a></li>
<li>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></li>
</ul>
<span id="more"></span>

<h2 id="缓存准则"><a href="#缓存准则" class="headerlink" title="缓存准则"></a>缓存准则</h2><ul>
<li>代码应始终具有用于提取数据的选项，而不是依赖于可用的缓存值。</li>
<li>缓存的是内存资源，内存资源是有限的因此需要限制缓存增长：<ul>
<li>请勿将外部输入用作缓存Key，如果任由外部输入作为Key，那缓存很容易就会被恶意刷爆。</li>
<li>使用过期时间策略限制缓存增长，这能够及时释放不活跃的缓存，及时释放内存空间。</li>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory?view=aspnetcore-3.1#use-setsize-size-and-sizelimit-to-limit-cache-size">使用 SetSize、Size 和 SizeLimit 限制缓存大小</a>。 ASP.NET Core运行时 <strong>不会根据</strong> 内存压力限制缓存大小。 由开发人员限制缓存大小。</li>
</ul>
</li>
</ul>
<h2 id="客户端缓存-Cache-control"><a href="#客户端缓存-Cache-control" class="headerlink" title="客户端缓存 Cache-control"></a>客户端缓存 Cache-control</h2><p>Http协议中规定，服务器端通过返回报文头添加Cache-control，来达到通知客户端进行缓存，如：<code>Cache-control:max-age=30</code>，表示让客户端缓存该内容30秒（当然客户端也可以不干）。</p>
<p>在ASP.NET Core中，可以通过添加<code>ResponseCacheAttribute</code>这个Attribute，让程序在返回时的添加报文头<code>Cache-control</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端缓存只对本客户端有效，在你使用另一个客户端发出一样的请求是，你就会发现访问的不是缓存了的数据，而是最新数据。这时候就需要使用服务端缓存了。</p>
<h2 id="服务器端响应缓存-ResponseCaching"><a href="#服务器端响应缓存-ResponseCaching" class="headerlink" title="服务器端响应缓存 ResponseCaching"></a>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></h2><p>ASP.NET Core不但可以设置浏览器缓存，还可以设置服务器端的响应缓存，当请求某资源时，响应的内容会被服务器进行缓存，在缓存有效期内，就算不同客户端获取同一资源也不会真的进入该资源地址获取数据，而是由缓存直接返回内容。</p>
<p>要使用服务器缓存，需要以下步骤：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.Configure</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>同样需要添加<code>ResponseCacheAttribute</code>这个Attribute：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这时候你通过同一客户端多次访问该资源发现第二次以后的访问的是客户端缓存，通过不同客户端访问的是服务器缓存的内容。</p>
<p>虽然服务器端响应缓存看起来很美好，不过实际上有点中看不中用，应为其生效是有条件的，而且还挺苛刻，实际上只要请求的报文头加上<code>Cache-Control:no-cache</code>，就可以让服务器响应缓存失效。所以一般我们更加依赖于：<code>内存缓存</code>、<code>分布式缓存</code>。</p>
<h3 id="缓存条件"><a href="#缓存条件" class="headerlink" title="缓存条件"></a>缓存条件</h3><ul>
<li>请求必须生成状态代码为”正常”的 200 (服务器) 响应。</li>
<li>请求方法必须是 GET 或 HEAD。</li>
<li>在 <code>Startup.Configure</code> 中，Caching中间件的中间件之前必须放置需要缓存的中间件。 有关详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1">ASP.NET Core 中间件</a>。</li>
<li><code>Authorization</code>标头不能存在。</li>
<li><code>Cache-Control</code> 标头参数必须有效，并且响应必须标记 <code>public</code> 且未标记为 <code>private</code> 。</li>
<li>如果标头不存在，则标头不得存在，因为标头 <code>Pragma: no-cache</code> <code>Cache-Control</code> 将替代标头（ <code>Cache-Control</code> <code>Pragma</code> 如果存在）。</li>
<li><code>Set-Cookie</code>标头不能存在。</li>
<li><code>Vary</code> 标头参数必须有效且不等于 <code>*</code> 。</li>
<li>如果 <code>Content-Length</code> 设置了 (标头值) 必须与响应正文的大小匹配。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.features.ihttpsendfilefeature">IHttpSendFileFeature</a>未使用 。</li>
<li>响应不能像 标头和 和 缓存 <code>Expires</code> 指令所指定 <code>max-age</code> 一 <code>s-maxage</code> 样过时。</li>
<li>响应缓冲必须成功。 响应的大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.sizelimit#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_SizeLimit">SizeLimit</a> 。 响应的正文大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.maximumbodysize#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_MaximumBodySize">MaximumBodySize</a> 。</li>
<li>响应必须可缓存，符合 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 规范。 例如，指令 <code>no-store</code> 不得存在于请求或响应标头字段中。 有关详细信息 <em>，请参阅第 3</em> 部分：在 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 的缓存中存储响应。</li>
</ul>
<h2 id="内存缓存-IMemoryCache"><a href="#内存缓存-IMemoryCache" class="headerlink" title="内存缓存  IMemoryCache"></a>内存缓存  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.memory.imemorycache">IMemoryCache</a></h2><p>内存缓存是数据保存在当前运行的网站的内存中，是与进程相关的。而由于在Web服务器中，多个不同网站时运行在不同进程中的，因此不同网站的内存时不会互相干扰的，也就意味着不能直接访问不在同一进程中的其他应用程序的内存缓存，然后需要注意的是网站重启后，内存缓存中的数据会被情况。</p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.caching">System.Runtime.Caching</a>/<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.caching.memorycache">MemoryCache</a></p>
<p>要使用内存缓存，需要：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddMemoryCache();</span><br></pre></td></tr></table></figure></li>
<li><p>注入<code>IMemoryCache</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = memoryCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>TryGetValue</code>、<code>Remove</code>、<code>Set</code>、<code>GetOrCreate</code>等方法操作MemoryCache</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryCacheController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = memoryCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strName = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一、使用TryGetValue与Set</span></span><br><span class="line">        <span class="comment">//if (!_cache.TryGetValue(&quot;Name&quot;, out strName))</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    strName = GetNmae(id);</span></span><br><span class="line">        <span class="comment">//    _cache.Set(&quot;Name&quot;, strName);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//方法二、使用GetOrCreate</span></span><br><span class="line">        <span class="comment">//strName = _cache.GetOrCreate&lt;string&gt;(&quot;Name&quot;, (e) =&gt; &#123; return GetNmae(id); &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Remove&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">string</span> cacheName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache.Remove(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetNmae</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="string">&quot;Singo&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="string">&quot;古月&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="literal">default</span>: <span class="keyword">return</span> <span class="string">&quot;无名&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>访问<code>Get</code>方法获得数据并设置一个名字为”Name”的MemoryCache，在过期前再次访问获得的都是MemoryCache里的数据，可以通过访问<code>Remove</code>方法，传入参数”Name”，即可清除名字为”Name”的MemoryCache。</p>
<h3 id="过期时间策略"><a href="#过期时间策略" class="headerlink" title="过期时间策略"></a>过期时间策略</h3><p>默认情况下内存缓存是不会过期的，因此我们可以通过<code>Remove</code>方法删除缓存，或者使用<code>Set</code>方法重新设置缓存，不过在实际应用中大部分时间不会这么做，因为这么弄很麻烦，更常用的办法时使用过期时间来管理。</p>
<p>过期时间策略有两种</p>
<ul>
<li><p>绝对过期时间，通过设置<code>ICacheEntry.AbsoluteExpirationRelativeToNow</code>(过多少时间后失效)或<code>ICacheEntry.AbsoluteExpiration</code>(什么时间点失效)。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123; <span class="keyword">return</span> GetNmae(id); &#125;);</span><br><span class="line"><span class="comment">//5秒后过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在今天晚上23点失效</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpiration = System.DateTime.Today.AddHours(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>滑动过期时间，通过设置<code>ICacheEntry.SlidingExpiration</code>(过多少时间后失效，但是如果在失效前一直有访问尽量，那就会延长设置的时间（注意是在被访问的时间点上），直到过期。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5秒后过期，假如在过期前被访问，以被访问时间点位基准再次延迟5秒，直到过期</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.SlidingExpiration = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>不过可以混用两种策略，让缓存数据能够在滑动过期时间的基础上，通过设置绝对过期时间来达到强制刷新数据的目的，也就是说在绝对过期时间这个点数据必定过期，滑动时间影响不了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//混用绝对过期时间与滑动过期时间</span></span><br><span class="line">strName = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Name&quot;</span>, (e) =&gt; &#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = System.TimeSpan.FromSeconds(<span class="number">15</span>);  <span class="comment">//绝对过期时间15秒</span></span><br><span class="line">    e.SlidingExpiration = System.TimeSpan.FromSeconds(<span class="number">5</span>);  <span class="comment">//滑动过期时间5秒</span></span><br><span class="line">    <span class="keyword">return</span> GetNmae(id); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>  缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p><strong>解决办法</strong>：在基础过期时间的基础上，加上一个随机时间，防止同一时间大量数据过期现象发生。如：本来统一设置位3分钟的，变为3分钟加1-15秒的随机数。</p>
<h2 id="分布式缓存-DistributedCache"><a href="#分布式缓存-DistributedCache" class="headerlink" title="分布式缓存 DistributedCache"></a>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></h2><p>内存缓存在比较简单的应用里是足够使用的，但是对于现在需要多台服务器进行负载均衡的架构环境中就显得有点不太够用，如会出现：缓存内容不一致、多台服务器缓存同一内容浪费内存空间等问题，因此需要一个独立的统一的缓存存储中心，以便让所有的Web服务器共享同一份缓存数据，我们将这种缓存形式称为<strong>分布式缓存</strong>。</p>
<p>有关.NET Core的分布式缓存如下：</p>
<ul>
<li><p>.NET Core没有内置分布式缓存，但是却提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法实际与内存缓存类似。</p>
</li>
<li><p>可以使用常用分布式缓存如<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>、<a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>、<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>、<a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>等。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>：缓存性能并不好，基本不考虑。</p>
<p><a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>：缓存专用，性能非常高能，可惜对集群、高可用方面支持比较弱，而且有<em>缓存键最大长度为250字节</em>（以前做项目刚用时就被坑过，超过了就直接截断，也没报错提醒）、*<em>最大只能存储1MB的单个item</em>等限制。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>：虽然做缓存服务器的性能比Memcached稍差，但是其高可用、集群等方面非常强大，适合在数据量大及集群等场景使用，并且缓存外的功能也很强大，还能做消息队列等。</p>
<p><a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>：它是一个高性能的、分布式的、可扩展的、天生为.Net设计的缓存框架，NCache不仅比 Redis 快，而且还提供了一些Redis所不具有的分布式特性。</p>
</li>
<li><p>分布式缓存其缓存值的类型为<code>byte[]</code>，虽然也提供了接受string的类型的方法，但是最终都会转换为<code>byte[]</code>，而且本身IDistributedCache提供的方法有限，最好扩展IDistributedCache的方法。</p>
</li>
</ul>
<h3 id="IDistributedCache接口包含以下方法"><a href="#IDistributedCache接口包含以下方法" class="headerlink" title="IDistributedCache接口包含以下方法"></a>IDistributedCache接口包含以下方法</h3><ul>
<li><p>Get、GetAsync</p>
<p>  采用字符串键并以byte[]形式检索缓存项（如果在缓存中找到）。</p>
</li>
<li><p>Set、SetAsync</p>
<p>  使用字符串键向缓存添加项byte[]形式）。</p>
</li>
<li><p>Refresh、RefreshAsync</p>
<p>  根据键刷新缓存中的项，并重置其可调过期超时值（如果有）。</p>
</li>
<li><p>Remove、RemoveAsync</p>
<p>  根据键删除缓存项。</p>
</li>
</ul>
<h3 id="Redis-分布式缓存"><a href="#Redis-分布式缓存" class="headerlink" title="Redis 分布式缓存"></a>Redis 分布式缓存</h3><ol>
<li><p>安装Redis相关包，这个包是微软提供的</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">install-package</span> Microsoft.Extensions.Caching.StackExchangeRedis</span><br><span class="line">//注意以前使用的是：Microsoft.Extensions.Caching.Redis包，不过这个包<span class="number">2018</span>年后就没更新了</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.ConfigureServices</code>中注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Use Redis</span></span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt; &#123;</span><br><span class="line">    options.Configuration = <span class="string">&quot;localhost&quot;</span>;  <span class="comment">//使用本地</span></span><br><span class="line">    options.InstanceName = <span class="string">&quot;SampleInstance_&quot;</span>;  <span class="comment">//添加前缀可以区别于其他应用来的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>注入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Get&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Set&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Set</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> absoluteExpirationRelativeToNowSec = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> slidingExpirationSec = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加，注意：添加Redis后的类型是hash</span></span><br><span class="line">            <span class="comment">//默认没有过期时间</span></span><br><span class="line">            <span class="comment">//_cache.Set(&quot;id1&quot;, Encoding.Default.GetBytes(&quot;永不过期，缓存时间是：&#123;DateTime.Now.ToLongTimeString()&#125;&quot;), new DistributedCacheEntryOptions &#123; &#125;);</span></span><br><span class="line">            <span class="comment">//同样可以设置绝对过期时间与滑动过期时间</span></span><br><span class="line">            _cache.Set(</span><br><span class="line">                <span class="string">&quot;id1&quot;</span>,</span><br><span class="line">                Encoding.Default.GetBytes(<span class="string">$&quot;缓存时间是：<span class="subst">&#123;DateTime.Now.ToLongTimeString()&#125;</span>，过期时间是：<span class="subst">&#123;DateTime.Now.AddSeconds(absoluteExpirationRelativeToNowSec).ToLongTimeString()&#125;</span>&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> DistributedCacheEntryOptions</span><br><span class="line">                &#123;</span><br><span class="line">                    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(absoluteExpirationRelativeToNowSec),</span><br><span class="line">                    SlidingExpiration = TimeSpan.FromSeconds(slidingExpirationSec)</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Del&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Del</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移除</span></span><br><span class="line">        _cache.Remove(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Refresh&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Refresh</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//刷新，Get命令同样会刷新滑动过期时间</span></span><br><span class="line">        _cache.Refresh(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文章是基本上是基于ASP.NET Core3.1版本编写，其后续版本可能发生变化，具体使用请去<a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a>查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He">.NET 6教程，.Net Core 2022视频教程，杨中科主讲</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.Net Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.Net Core</tag>
        <tag>Caching</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
