<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASP.NETCore使用Swagger</title>
    <url>/2022/01/+ASP.NETCore%E4%BD%BF%E7%94%A8Swagger/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是swagger"><a href="#什么是swagger" class="headerlink" title="什么是swagger"></a>什么是swagger</h2><p><a href="https://swagger.io/">swagger</a>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。</p>
<p>简单来讲，使用swagger能够自动生成友好的在线接口文档，并且支持接口测试，其好处：</p>
<ul>
<li>对后端人员：减少了编写接口后还要花费时间同步更新接口文档，且与前端沟通的时间成本。</li>
<li>对前端人员：能够直观的快速的看到接口，并且进行在线测试，方便了调试调用接口，不用因接口问题频繁与后端沟通。</li>
</ul>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>框架.net3.1默认没有swagger，需要自己弄，以下简单写步骤</p>
<ol>
<li><p>nuget安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Swashbuckle.AspNetCore</span><br></pre></td></tr></table></figure></li>
<li><p>Startup.cs文件引入命名空间</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Swashbuckle.AspNetCore.Swagger;</span><br><span class="line"><span class="keyword">using</span> Microsoft.OpenApi.Models;</span><br></pre></td></tr></table></figure></li>
<li><p>将 Swagger 生成器添加到 <code>Startup.ConfigureServices</code> 方法中的服务集合中</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>Startup.Configure</code> 方法中，启用中间件为生成的 JSON 文档和 Swagger UI 提供服务</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>此时启动项目就可通过<code>http://localhost:&lt;port&gt;/swagger</code>地址访问Swagger UI浏览API文档。</p>
<p>   也可通过<code>http://localhost:&lt;port&gt;/swagger/v1/swagger.json</code>地址访问生成的描述终结点的json文档。</p>
</li>
<li><p>如果要想通过<code>http://localhost:&lt;port&gt;/</code>就访问Swagger UI，修改启用中间件SwaggerUI的方法<code>UseSwaggerUI</code>，把<code>RoutePrefix</code> 属性设置为空字符串。</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="添加版本控制"><a href="#添加版本控制" class="headerlink" title="添加版本控制"></a>添加版本控制</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>添加API枚举类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 版本控制</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ApiVersion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v1版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V1 = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> v2版本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    V2 = <span class="number">2</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历版本信息</span></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerDoc(version, <span class="keyword">new</span> OpenApiInfo</span><br><span class="line">        &#123;</span><br><span class="line">            Version = version, <span class="comment">//版本号</span></span><br><span class="line">            Title = <span class="string">$&quot;My API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//标题</span></span><br><span class="line">            Description = <span class="string">$&quot;My ASP.NET Core Web API <span class="subst">&#123;version&#125;</span>&quot;</span>, <span class="comment">//描述</span></span><br><span class="line">            <span class="comment">//上面三项最后设置，下面的三项可以不用</span></span><br><span class="line">            TermsOfService = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/terms&quot;</span>), <span class="comment">//服务条款</span></span><br><span class="line">            Contact = <span class="keyword">new</span> OpenApiContact</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Singo&quot;</span>, <span class="comment">//联系人</span></span><br><span class="line">                Email = <span class="built_in">string</span>.Empty,  <span class="comment">//邮箱</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://github.com/hushitong&quot;</span>),<span class="comment">//网站</span></span><br><span class="line">            &#125;,</span><br><span class="line">            License = <span class="keyword">new</span> OpenApiLicense</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Use under LICX&quot;</span>, <span class="comment">//协议</span></span><br><span class="line">                Url = <span class="keyword">new</span> Uri(<span class="string">&quot;https://example.com/license&quot;</span>), <span class="comment">//协议地址</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.Configure</code> 里启用中间件的设置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务生成Swagger作为JSON终结点</span></span><br><span class="line">app.UseSwagger();</span><br><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typeof</span>(ApiVersion).GetEnumNames().ToList().ForEach(version =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//描述终结点的json文档</span></span><br><span class="line">        c.SwaggerEndpoint(<span class="string">$&quot;/swagger/<span class="subst">&#123;version&#125;</span>/swagger.json&quot;</span>, version);</span><br><span class="line">        <span class="comment">//设置为none可折叠所有方法</span></span><br><span class="line">        c.DocExpansion(Swashbuckle.AspNetCore.SwaggerUI.DocExpansion.None);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>然后就是使用ApiExplorerSettingsAttribute标注各个版本Controller，然后修改路由信息</p>
<p>原来的标注为</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V1))</span>]</span><br></pre></td></tr></table></figure>

<p>后来的根据需要标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiExplorerSettings(GroupName = nameof(ApiVersion.V2))</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>启动后就可以通过右上角的下拉框选择需要的版本进行测试了</p>
</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有关版本控制实际有很多办法，如：可以查看<a href="https://www.cnblogs.com/Leo_wl/p/7508650.html">Net Core WebApi几种版本控制对比</a></p>
<h2 id="添加JWT支持"><a href="#添加JWT支持" class="headerlink" title="添加JWT支持"></a>添加JWT支持</h2><ol>
<li><p>修改<code>Startup.ConfigureServices</code>里注册Swagger的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册Swagger生成器，定义一个和多个Swagger 文档</span></span><br><span class="line">services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerDoc(<span class="string">&quot;v1&quot;</span>, <span class="keyword">new</span> OpenApiInfo &#123; Title = <span class="string">&quot;My API&quot;</span>, Version = <span class="string">&quot;v1&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 添加JWT支持</span></span><br><span class="line">    c.AddSecurityDefinition(<span class="string">&quot;Bearer&quot;</span>, <span class="keyword">new</span> OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = <span class="string">&quot;在下框中输入请求头中需要添加Jwt授权Token：Bearer Token&quot;</span>,</span><br><span class="line">        Name = <span class="string">&quot;Authorization&quot;</span>, <span class="comment">//设置其key名，请求时会添加上，默认使用Authorization名</span></span><br><span class="line">        In = ParameterLocation.Header, <span class="comment">//在请求头添加JWT Token</span></span><br><span class="line">        Type = SecuritySchemeType.ApiKey,</span><br><span class="line">        BearerFormat = <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">        Scheme = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    c.AddSecurityRequirement(<span class="keyword">new</span> OpenApiSecurityRequirement</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> OpenApiSecurityScheme</span><br><span class="line">            &#123;</span><br><span class="line">                Reference = <span class="keyword">new</span> OpenApiReference &#123;</span><br><span class="line">                    Type = ReferenceType.SecurityScheme,</span><br><span class="line">                    Id = <span class="string">&quot;Bearer&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>运行进入SeaggerUI页面，可以看到在页面右上角多了一个<code>Authorize</code>按钮，点击在value框可以填入<code>bear &lt;your jwt string&gt;</code>，以后请求头都会带上<code>Authorization: bear &lt;your jwt string&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/SwaggerWithJWT.png" alt="SwaggerWithJWT"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>文档</tag>
        <tag>Swagger</tag>
        <tag>版本控制</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore依赖注入提议</title>
    <url>/2022/01/+ASP.NETCore%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%8F%90%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="有关服务的生命周期"><a href="#有关服务的生命周期" class="headerlink" title="有关服务的生命周期"></a>有关服务的生命周期</h3><ul>
<li><p>尽可能将您的服务注册为瞬态服务。 因为设计瞬态服务很简单。 您通常不用关心多线程和内存泄漏，并且您知道该服务的寿命很短。</p>
</li>
<li><p>请谨慎使用Scoped，因为如果您创建子服务作用域或从非Web应用程序使用这些服务，则可能会非常棘手。</p>
</li>
<li><p>谨慎使用Singleton，因为您需要处理多线程和潜在的内存泄漏问题。</p>
</li>
<li><p>在Singleton服务中不要依赖Transient或者Scoped服务，因为如果当一个Singleton服务注入Transient服务，这个Transient服务就会变成一个Singleton服务，并且如果Transient服务不是为支持这种情况而设计的，则可能导致问题。 在这种情况下，ASP.NET Core的默认DI容器已经抛出异常。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="有关注册的服务使用"><a href="#有关注册的服务使用" class="headerlink" title="有关注册的服务使用"></a>有关注册的服务使用</h3><ul>
<li>在我们注册服务后，通常使用的是<code>构造函数注入</code>的方式来注入所需依赖项</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IProductRepository _productRepository;</span><br><span class="line">    <span class="comment">//构造函数注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductService</span>(<span class="params">IProductRepository productRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _productRepository = productRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _productRepository.Delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而避免<code>服务定位器</code>，因为该模式存在隐含的依赖关系，这意味着在创建服务实例时无法轻松查看依赖关系。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IProductRepository _productRepository;</span><br><span class="line">    <span class="comment">//服务定位器注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductService</span>(<span class="params">IServiceProvider serviceProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _productRepository = serviceProvider</span><br><span class="line">          .GetRequiredService&lt;IProductRepository&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _productRepository.Delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMes</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有些种情况不适合使用<code>构造函数注入</code>，如注入的服务的实例的构造函数执行过于慢，如上面<code>IProductRepository</code>的实例，假设其构造函数需要花费1秒，那就会导致我们就算只是想访问ProductService的方法<code>ShowMes()</code>时，都需要等待至少1秒，这很糟糕，我们当然可以把该方法单独出来，但这明显不是一个很好的做法。</p>
<p>这时候我们就需要在使用时再用<code>服务定位器</code>方式获得其实例，如</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _productRepository = serviceProvider</span><br><span class="line">          .GetRequiredService&lt;IProductRepository&gt;();</span><br><span class="line">    _productRepository.Delete(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Asp.Net Core中，还有使用<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.fromservicesattribute">FromServices</a>特性修饰的办法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params">[FromServices] IAccountService accountService, <span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将注入的依赖项分配给<strong>只读【readonly】</strong>字段/属性（防止在方法内意外地为其分配另外一个值）。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IProductRepository _productRepository;</span><br></pre></td></tr></table></figure>

<h3 id="获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期"><a href="#获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期" class="headerlink" title="获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期"></a>获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取当前注册的所有服务，并打印每个服务对应的声明类型、实现类型和生命周期</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetDIShowList</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    sb.AppendLine(<span class="string">$&quot;Services Count: <span class="subst">&#123;services.Count&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> provider = services.BuildServiceProvider();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> service <span class="keyword">in</span> services)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceTypeName = GetName(service.ServiceType);</span><br><span class="line">        <span class="keyword">var</span> implementationType = service.ImplementationType</span><br><span class="line">                ?? service.ImplementationInstance?.GetType()</span><br><span class="line">                ?? service.ImplementationFactory?.Invoke(provider)?.GetType();</span><br><span class="line">        <span class="keyword">if</span> (implementationType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.AppendLine(<span class="string">$&quot;<span class="subst">&#123;service.Lifetime,<span class="number">-15</span>&#125;</span> <span class="subst">&#123;serviceTypeName,<span class="number">-50</span>&#125;</span><span class="subst">&#123;GetName(implementationType)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!type.IsGenericType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> type.Name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> name = type.Name.Split(<span class="string">&#x27;`&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> args = type.GetGenericArguments().Select(it =&gt; it.Name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;name&#125;</span>&lt;<span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, args)&#125;</span>&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ShowServicesListOnConsole = <span class="string">&quot;true&quot;</span>; <span class="comment">//Configuration.GetSection(&quot;ShowServicesListOnConsole&quot;).Value;</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(ShowServicesListOnConsole) &amp;&amp; ShowServicesListOnConsole.ToLower() == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(GetDIShowList(services));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会显示类似</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Services Count: <span class="number">175</span></span><br><span class="line">Singleton       IHostingEnvironment                               HostingEnvironment</span><br><span class="line">Singleton       IHostEnvironment                                  HostingEnvironment</span><br><span class="line">Singleton       HostBuilderContext                                HostBuilderContext</span><br><span class="line">Singleton       IConfiguration                                    ConfigurationRoot</span><br><span class="line">Singleton       IApplicationLifetime                              ApplicationLifetime</span><br><span class="line">Singleton       IHostApplicationLifetime                          ApplicationLifetime</span><br><span class="line">Singleton       IHostLifetime                                     ConsoleLifetime</span><br><span class="line">Singleton       IHost                                             Host</span><br><span class="line">Singleton       IOptions&lt;TOptions&gt;                                UnnamedOptionsManager&lt;TOptions&gt;</span><br><span class="line">Scoped          IOptionsSnapshot&lt;TOptions&gt;                        OptionsManager&lt;TOptions&gt;</span><br><span class="line">Singleton       IOptionsMonitor&lt;TOptions&gt;                         OptionsMonitor&lt;TOptions&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>DI</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore如何解密Cookie</title>
    <url>/2022/02/+ASP.NETCore%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86Cookie/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事情的起点就在于我在弄ASP .NET Core下的OAuth2.0流程，想要看看具体的Cookie信息有哪些，发现Cookie信息被加密了，检索了一番，发现了解决办法 <a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86Cookie">如何解密Cookie</a> ，然后顺便找了一下原理。</p>
<h2 id="如何解密Cookie"><a href="#如何解密Cookie" class="headerlink" title="如何解密Cookie"></a>如何解密Cookie</h2><p>主要代码来源：<a href="https://stackoverflow.com/questions/42842511/how-to-manually-decrypt-an-asp-net-core-authentication-cookie">How to manually decrypt an ASP.NET Core Authentication cookie?</a></p>
<span id="more"></span>

<ol>
<li><p><code>Startup.CongigureServices</code>里注册的部分代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddAuthentication(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当我们登陆后，设置Cookie</span></span><br><span class="line">    config.DefaultSignInScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">    <span class="comment">//使用作为验证是否登陆</span></span><br><span class="line">    config.DefaultAuthenticateScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">&#125;).AddCookie(<span class="string">&quot;MyCookieScheme&quot;</span>, options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置密钥存储位置，你也可以使用services.AddDataProtection().PersistKeysToFileSystem(new DirectoryInfo(@&quot;C:\temp-keys2\&quot;))</span></span><br><span class="line">    options.DataProtectionProvider = DataProtectionProvider.Create(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;C:\temp-keys\&quot;</span>));</span><br><span class="line">    options.Cookie.Name = <span class="string">&quot;MyClientCookie&quot;</span>; <span class="comment">//默认为：.AspNetCore.Cookies</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>解密Cookie</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">DecryptCookie</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获得加密了的Cookie值，Cookie名假如注册时候没指定的话为：.AspNetCore.Cookies</span></span><br><span class="line">    <span class="built_in">string</span> cookieValue = HttpContext.Request.Cookies[<span class="string">&quot;MyClientCookie&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Create方法生成DataProtectionProvider对象，密钥存储位置值与在ConfigureServices注册时一致</span></span><br><span class="line">    <span class="keyword">var</span> provider = DataProtectionProvider.Create(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;C:\temp-keys\&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得DataProtector对象，第二个参数的值你在注册Cookies时候设定的Scheme名，没有设定的话其默认值为：Cookies</span></span><br><span class="line">    <span class="keyword">var</span> dataProtector = provider.CreateProtector(<span class="string">&quot;Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationMiddleware&quot;</span>, <span class="string">&quot;MyCookieScheme&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解密Cookie值，变为普通文本</span></span><br><span class="line">    <span class="built_in">byte</span>[] protectedBytes = Base64UrlTextEncoder.Decode(cookieValue);</span><br><span class="line">    <span class="built_in">byte</span>[] plainBytes = dataProtector.Unprotect(protectedBytes);</span><br><span class="line">    <span class="built_in">string</span> plainText = Encoding.UTF8.GetString(plainBytes);</span><br><span class="line">    <span class="comment">//上面的Encoding.UTF8.GetString不行的话使用下面的</span></span><br><span class="line">    <span class="comment">//UTF8Encoding specialUtf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: false);</span></span><br><span class="line">    <span class="comment">//string plainText = specialUtf8Encoding.GetString(plainBytes);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或解密Cookie值，转换为AuthenticationTicket对象</span></span><br><span class="line">    TicketDataFormat ticketDataFormat = <span class="keyword">new</span> TicketDataFormat(dataProtector);</span><br><span class="line">    AuthenticationTicket ticket = ticketDataFormat.Unprotect(cookieValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(JsonConvert.SerializeObject(ticket.Properties.Items));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li><p>最重要的是设置保存到 <code>C:\temp-keys\</code> 下的私钥文件，有了这文件，你加密的Cookie能被任何人解密。</p>
</li>
<li><p>当然你可以不存储到文件，还有其他办法，具体参考：<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/implementation/key-storage-providers">ASP.NET Core 中的密钥存储提供程序</a></p>
</li>
</ul>
<h2 id="简单说说原理"><a href="#简单说说原理" class="headerlink" title="简单说说原理"></a>简单说说原理</h2><h3 id="默认Cookie不加密"><a href="#默认Cookie不加密" class="headerlink" title="默认Cookie不加密"></a>默认Cookie不加密</h3><p>当我们直接添加的Cookie默认是不经过加密的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HttpContext.Response.Cookies.Append(<span class="string">&quot;web_nmae&quot;</span>,<span class="string">&quot;MyWeb&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="认证-Authentication-使用Cookie认证方案时认证信息加密"><a href="#认证-Authentication-使用Cookie认证方案时认证信息加密" class="headerlink" title="认证(Authentication)使用Cookie认证方案时认证信息加密"></a>认证(Authentication)使用Cookie认证方案时认证信息加密</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册</span></span><br><span class="line">services.AddAuthentication(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//但我们登陆后，设置Cookie</span></span><br><span class="line">    config.DefaultSignInScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">    <span class="comment">//使用作为验证是否登陆</span></span><br><span class="line">    config.DefaultAuthenticateScheme = <span class="string">&quot;MyCookieScheme&quot;</span>;</span><br><span class="line">&#125;).AddCookie(<span class="string">&quot;MyCookieScheme&quot;</span>, options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//options.DataProtectionProvider = DataProtectionProvider.Create(new DirectoryInfo(@&quot;C:\temp-keys\&quot;));</span></span><br><span class="line">    options.Cookie.Name = <span class="string">&quot;MyClientCookie&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SignIn接口</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">SignIn</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;singo&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;4433&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    ClaimsIdentity claimsIdentity = <span class="keyword">new</span> ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);</span><br><span class="line">    <span class="keyword">var</span> claimsPrincipal = <span class="keyword">new</span> ClaimsPrincipal(claimsIdentity);</span><br><span class="line">    <span class="keyword">await</span> HttpContext.SignInAsync(claimsPrincipal);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;SignIn成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">SetCookie</span>(<span class="params"><span class="built_in">string</span> key,<span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用该方法设置Cookie不会被加密</span></span><br><span class="line">    HttpContext.Response.Cookies.Append(key, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;SetCookie成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用SignIn接口，查看Cookies，就能发现一个Cookie项，其value被加密了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">key: MyClientCookie</span><br><span class="line">value: CfDJ8FY8TudSY7lKgK5Kc1rjrPANTxtvOw87CVoObdVDdNug6_nTvgFZWRANLhPQBRrrhBQjWItfG51Xsdc1SaXDRTBDfxLWl-iSzKX5NnUUf3U9hM5ptcrXkPbDnvZKWtjtgr9gY1A5lIbqsZTjDwrQR5jNBxu81LzCz8_vJBRma2yrmjc9UIc_3vyxXX5pkMWk1Rt6-QHXFuRUdHbHjuN_jRckKFmzIUHJ_dlpzTGbhwTeMRLUJwAJT6zP56XeR_A_k00GEULumSHYqCopbhOKHe89kA75_tuj2Sg1EPVK0oJ1DfGIusleH3qdbWN4ZRsFQ0QLYdalm05i0r1nx_cbGJPQhT0thFqNj-zdOkXKaEEZvGrl6kSQr4NM0IhtBed2HeibJsw9gSKVCNiQAPTMVoGnVnM4cr6A1e6uyEn9CO4IB-VhjULeE8GT0BJ0nD6VatLKq6aXbxVS5Mwfnhs4ZgxpFJ_u-IY3hL3joOYfmAcIJi1R3XFypmPAAp3AeMHn9qIuxKpCDF8ybQSPqRn_wIfLA9KUt5WGlZX5y_nvdfiX-HaPEmytZtyi69k5MPZxmOAeTHh9r1i6HCRYN6veFmjDC7y7kJhSxvxiWePmTfHx</span><br></pre></td></tr></table></figure>

<h3 id="查看HttpContext-SignInAsync源码"><a href="#查看HttpContext-SignInAsync源码" class="headerlink" title="查看HttpContext.SignInAsync源码"></a>查看HttpContext.SignInAsync源码</h3><p>然后去找源代码看，最后会发现其中的关键就是<code>CookieAuthenticationHandler.cs</code>文件下的<code>HandleSignInAsync</code>方法，我把其简化了贴出来</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">HandleSignInAsync</span>(<span class="params">ClaimsPrincipal user, AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Process the request cookie to initialize members like _sessionKey.</span></span><br><span class="line">    <span class="keyword">await</span> EnsureCookieTicket();</span><br><span class="line">    <span class="keyword">var</span> cookieOptions = BuildCookieOptions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> signInContext = <span class="keyword">new</span> CookieSigningInContext(</span><br><span class="line">        Context,</span><br><span class="line">        Scheme,</span><br><span class="line">        Options,</span><br><span class="line">        user,</span><br><span class="line">        properties,</span><br><span class="line">        cookieOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!signInContext.Properties.ExpiresUtc.HasValue)</span><br><span class="line">    &#123;</span><br><span class="line">        signInContext.Properties.ExpiresUtc = issuedUtc.Add(Options.ExpireTimeSpan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Events.SigningIn(signInContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signInContext.Properties.IsPersistent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> expiresUtc = signInContext.Properties.ExpiresUtc ?? issuedUtc.Add(Options.ExpireTimeSpan);</span><br><span class="line">        signInContext.CookieOptions.Expires = expiresUtc.ToUniversalTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ticket = <span class="keyword">new</span> AuthenticationTicket(signInContext.Principal!, signInContext.Properties, signInContext.Scheme.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里加密cookieValue</span></span><br><span class="line">    <span class="comment">//当你点到TicketDataFormat，会有提示如下</span></span><br><span class="line">    <span class="comment">//The TicketDataFormat is used to protect and unprotect the identity and other properties which are stored in the</span></span><br><span class="line">    <span class="comment">//cookie value. If not provided one will be created using &lt;see cref=&quot;DataProtectionProvider&quot;/&gt;.</span></span><br><span class="line">    <span class="keyword">var</span> cookieValue = Options.TicketDataFormat.Protect(ticket, GetTlsTokenBinding());</span><br><span class="line"></span><br><span class="line">    Options.CookieManager.AppendResponseCookie(</span><br><span class="line">        Context,</span><br><span class="line">        Options.Cookie.Name!,</span><br><span class="line">        cookieValue,</span><br><span class="line">        signInContext.CookieOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> signedInContext = <span class="keyword">new</span> CookieSignedInContext(</span><br><span class="line">        Context,</span><br><span class="line">        Scheme,</span><br><span class="line">        signInContext.Principal!,</span><br><span class="line">        signInContext.Properties,</span><br><span class="line">        Options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> Events.SignedIn(signedInContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only redirect on the login path</span></span><br><span class="line">    <span class="keyword">var</span> shouldRedirect = Options.LoginPath.HasValue &amp;&amp; OriginalPath == Options.LoginPath;</span><br><span class="line">    <span class="keyword">await</span> ApplyHeaders(shouldRedirect, signedInContext.Properties);</span><br><span class="line"></span><br><span class="line">    Logger.AuthenticationSchemeSignedIn(Scheme.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后的加密的依赖就是 <code>Data Protection</code></p>
<h3 id="Data-Protection"><a href="#Data-Protection" class="headerlink" title="Data Protection"></a><strong><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/introduction">Data Protection</a></strong></h3><blockquote>
<p>Data Protection 是微软提供的数据保护机制：</p>
<p>为了确保 Web 应用敏感数据的安全存储，该机制提供了一个简单、基于非对称加密改进的、性能良好的、开箱即用的加密 API 用于数据保护。</p>
<p>它不需要开发人员专门学习怎么样管理这些钥（公钥，私钥），系统回自动的选择算法和管理密钥的生命周期。理想情况下开发人员都不应该访问这些钥的原始文件。</p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>当我们 SignIn 时会把认证信息给 Data Protection 加密然后存储到 Cookie。</p>
<p>当我们获得其该 Cookie 进行认证时，该值又会被 Data Protection 给解密，默认该流程不需要用户设置，应用就会自动进行加解密。</p>
<h2 id="关于Data-Protection可扩展阅读"><a href="#关于Data-Protection可扩展阅读" class="headerlink" title="关于Data Protection可扩展阅读"></a>关于Data Protection可扩展阅读</h2><p><a href="https://www.cnblogs.com/savorboard/p/5778616.html">ASP.NET Core 数据保护（Data Protection）【上】</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/dotnet-core-data-protection.html">ASP.NET Core 数据保护（Data Protection）【中】</a></p>
<p>官方文档：</p>
<p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/introduction">ASP.NET Core 数据保护</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>Data Protection</tag>
        <tag>Cookie</tag>
        <tag>解密</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core的配置系统</title>
    <url>/2022/01/+ASP.NETCore%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下例子主要来源ASP.NET Core 3.1版本，后续版本可能会有所更改，请注意。</p>
<p>各版本区别既更多有关Configuration的信息，可以查看官方文档：<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration in ASP.NET Core</a></p>
<h2 id="关于ASP-NET-Core的配置"><a href="#关于ASP-NET-Core的配置" class="headerlink" title="关于ASP.NET Core的配置"></a>关于ASP.NET Core的配置</h2><p>ASP.NET Core 的配置遵循“约定大于配置”，是由一系列<code>Configuration providers</code>提供组合而成的。</p>
<p>ASP.NET Core Web应用，在建立引用服务前，会使用<code>Host.CreateDefaultBuilder</code>方法依次加载<code>Configuration providers</code>，顺序如下：</p>
<ol>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.chainedconfigurationsource">ChainedConfigurationProvider</a>：添加现有 <code>IConfiguration</code> 作为源。 在ASP.NET Core Web默认配置中，添加 Host 配置，并将它设置为应用配置的第一个源。</li>
<li>使用项目根目录下的<code>appsettings.json</code>。</li>
<li>使用项目根目录下的<code>appsettings.&#123;Environment&#125;.json</code> 提供 。 例如，appsettings.Production.json 和 appsettings.Development.json 。</li>
<li>当在 <code>Development</code> 环境中运行时，会加载“用户机密”的配置。</li>
<li>使用<code>系统环境变量</code>的配置。</li>
<li>使用<code>命令行参数</code>的配置。</li>
</ol>
<p>后来添加的配置会替代之前的配置。如：在<code>appsettings.json</code>中配置了<code>&quot;Name&quot;:&quot;Joe&quot;</code>，然后在命令行传了参数<code>&quot;Name&quot;:&quot;Jack&quot;</code>，那最终使用的就为后面的<code>&quot;Name&quot;:&quot;Jack&quot;</code>。</p>
<span id="more"></span>

<h2 id="关于配置的key与value"><a href="#关于配置的key与value" class="headerlink" title="关于配置的key与value"></a>关于配置的key与value</h2><h3 id="有关Key"><a href="#有关Key" class="headerlink" title="有关Key"></a>有关Key</h3><ul>
<li><p>不区分大小写。 例如，<code>ConnectionString</code> 和 <code>connectionstring</code> 被视为等效键。</p>
</li>
<li><p>如果在多个<code>Configuration providers</code>中设置了某一键和值，则会使用最后的<code>Configuration providers</code>中添加的值。 </p>
</li>
<li><p>采用<strong>扁平化处理</strong>，其分层键<code>:</code></p>
<p>如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;User&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tina&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Age&quot;</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会变成<code>&quot;User:Name&quot;:&quot;Tina&quot;</code>和<code>&quot;User:Age&quot;:18</code>这两项配置。</p>
<ul>
<li>在环境变量中，分隔符<code>:</code>可能无法适用于所有平台。 所有平台均支持采用双下划线 <code>__</code>，并且它在被程序读取后会自动转换为冒号 <code>:</code>。</li>
<li>在其他配置中，冒号分隔符 (<code>:</code>) 适用于所有平台。</li>
</ul>
</li>
</ul>
<h3 id="有关Value"><a href="#有关Value" class="headerlink" title="有关Value"></a>有关Value</h3><ul>
<li>储存为字符串类型。</li>
<li>NULL 值不能存储在配置中或绑定到对象。</li>
</ul>
<h2 id="Configuration-providers"><a href="#Configuration-providers" class="headerlink" title="Configuration providers"></a>Configuration providers</h2><p>前面提到过ASP.NET Core中的配置是由一系列<code>Configuration providers</code>提供组合而成的，下面是其列表</p>
<table>
<thead>
<tr>
<th align="left">providers</th>
<th align="left">通过以下对象提供配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/security/key-vault-configuration">Azure Key Vault configuration provider</a></td>
<td align="left">Azure Key Vault</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/quickstart-aspnet-core-app">Azure App configuration provider</a></td>
<td align="left">Azure 应用程序配置</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#command-line">Command-line configuration provider</a></td>
<td align="left">命令行参数</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#custom-configuration-provider">Custom configuration provider</a></td>
<td align="left">自定义源</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#environment-variables">Environment Variables configuration provider</a></td>
<td align="left">环境变量</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#file-configuration-provider">File configuration provider</a></td>
<td align="left">INI、JSON 和 XML 文件</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#key-per-file-configuration-provider">Key-per-file configuration provider</a></td>
<td align="left">目录文件</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#memory-configuration-provider">Memory configuration provider</a></td>
<td align="left">集合，如：Dictionary&lt;string, string&gt;</td>
</tr>
<tr>
<td align="left"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#security-and-user-secrets">User secrets</a></td>
<td align="left">用户机密文件</td>
</tr>
</tbody></table>
<p>具体要使用什么<code>providers</code>，请根据项目需要选择（点击对应的providers去查看），一般项目开发会用到命令行参数、JSON文件、及自定义源（如：数据库读取），用户机密文件，而生产环境需要用到JSON文件、及自定义源（如：数据库读取）、环境变量。</p>
<h2 id="查看加载的所有配置项"><a href="#查看加载的所有配置项" class="headerlink" title="查看加载的所有配置项"></a>查看加载的所有配置项</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在<code>Startup.Configure</code>中添加以下代码，然后访问网站下的<code>/dump-config</code>地址，可以看到列出了所有的配置项，包含该项由什么provider提供、由那个文件提供，对于后续检查配置项的问题十分有用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseEndpoints(endpoints =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    endpoints.MapGet(<span class="string">&quot;/dump-config&quot;</span>, <span class="keyword">async</span> ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> configInfo = (Configuration <span class="keyword">as</span> IConfigurationRoot).GetDebugView();</span><br><span class="line">            <span class="keyword">await</span> ctx.Response.WriteAsync(configInfo);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>以下代码是我使用反射来获得的内容，和上面有点不同，上面微软提供的不符合要求可以参考以下我的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得配置项列表，按照provider分组</span></span><br><span class="line"><span class="comment">//objcect用来放provider，IDictionary&lt;string, string&gt;用来放该provider有的配置</span></span><br><span class="line"><span class="keyword">static</span> Dictionary&lt;<span class="built_in">object</span>, IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; GetConfigList(IConfigurationRoot conf)</span><br><span class="line">&#123;</span><br><span class="line">    IDictionary&lt;<span class="built_in">object</span>, IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; keyValuePairs = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">object</span>, IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> confProvider <span class="keyword">in</span> conf.Providers)</span><br><span class="line">    &#123;</span><br><span class="line">        Type confProviderType = confProvider.GetType();</span><br><span class="line">        <span class="keyword">var</span> fatherProviderType = confProviderType.BaseType.BaseType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> datas = confProviderType.GetProperty(<span class="string">&quot;Data&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">        <span class="keyword">if</span> (datas != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> configurationValue = (IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;)datas.GetValue(confProvider);</span><br><span class="line">            <span class="keyword">if</span> (configurationValue.Count &gt; <span class="number">0</span>)</span><br><span class="line">                keyValuePairs.Add(confProvider, configurationValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyValuePairs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成输出的 string</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetConfigViewStr</span>(<span class="params">Dictionary&lt;<span class="built_in">object</span>, IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; keyValuePairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> keyValuePairs)</span><br><span class="line">    &#123;</span><br><span class="line">        stringBuilder.AppendLine(<span class="string">$&quot;****Provider : <span class="subst">&#123;pair.Key&#125;</span>****&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> keyValue <span class="keyword">in</span> pair.Value)</span><br><span class="line">        &#123;</span><br><span class="line">            stringBuilder.AppendLine(<span class="string">$&quot;Key = <span class="subst">&#123;keyValue.Key&#125;</span> : Value = <span class="subst">&#123;keyValue.Value&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.MapGet(<span class="string">&quot;/dump-config&quot;</span>, (RequestDelegate)(<span class="keyword">async</span> ctx =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pair = GetConfigList((app.Configuration <span class="keyword">as</span> IConfigurationRoot));</span><br><span class="line">    <span class="keyword">await</span> ctx.Response.WriteAsync(GetConfigViewStr(pair));</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>



<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>以下内容比较细碎，是一些不成体系内容，主要是为了帮助自己以后的回忆学习。</p>
<h3 id="reloadOnChange"><a href="#reloadOnChange" class="headerlink" title="reloadOnChange"></a>reloadOnChange</h3><p>项目需要添加自己的 json 配置文件，可以使用下面方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureAppConfiguration(config =&gt; config.AddJsonFile(<span class="string">&quot;mysettings.json&quot;</span>, optional: <span class="literal">true</span>, reloadOnChange: <span class="literal">true</span>))</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>第3行内容就是在项目根目录读取一个名为<code>mysettings.json</code>的json文件获得配置，<code>reloadOnChange: true</code>表示在该json文件内容修改后，会自动在读取该文件加载新的配置内容。</p>
<p>其<code>reloadOnChange</code>的实现是依靠<code>PhysicalFileProvider</code>的Watch方法，该方法会生成<code>FileSystemWatcher</code>对象来对这些文件或目录进行监控，针对这些文件或目录的变化（创建、修改、重命名和删除）都会实时地反映到Watch方法返回的<code>ChangeToken</code>上。</p>
<p>通过ChangeToken的<code>RegisterChangeCallback</code>方法可以注册一个回调方法，当监控的的对象出现变化时，便会执行预先注册的回调方法。</p>
<p>关于文件系统，可以看蒋金楠老师的<a href="https://www.cnblogs.com/artech/p/net-core-file-provider-03.html%E3%80%82">https://www.cnblogs.com/artech/p/net-core-file-provider-03.html。</a></p>
<p>虽然<code>reloadOnChange</code>很方便，但是请注意使用的方法，不然可能导致<code>FileSystemWatcher</code>对象无法释放导致线程占有率过高问题。如该案例：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MzI5Mzg1OA==&mid=2247490781&idx=1&sn=1c406cf01674635081de6eb46f2da6cf&chksm=a6986f9091efe6864a9af05ea293272f9d42587fb1863ce9e76286e885812f9b403c41126aa8&token=1740393079&lang=zh_CN#rd">记一次 .NET 某流媒体独角兽 API 句柄泄漏分析</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>Configuration</tag>
        <tag>配置</tag>
        <tag>Configuration providers</tag>
      </tags>
  </entry>
  <entry>
    <title>快速打开关闭sqlserver相关服务</title>
    <url>/2022/01/+%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E5%85%B3%E9%97%ADSqlserver%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL Server安装后默认是一直随系统启动的，对于服务器当然没问题，但是对于个人开发而言，确实是不希望在不需要时一直运行相关SQL Server的服务。毕竟个人电脑性能有限，还是希望软件能够要用的才打开，不需要时能够释放占用的性能。</p>
<p>于是就有了这篇文章，提供一个脚本，需要时开启SQL Server相关服务，不需要是关闭SQL Server相关服务。</p>
<span id="more"></span>

<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>复制下面代码到文本文件，然后保存后改文件后缀名为.bat，然后<strong>以管理员身份运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::脚本目的：需要用sqlserver快速开启相关服务，不需要时快速关闭相关服务已节省资源</span><br><span class="line">::测试SQL版本：SQL Server 2008 R2</span><br><span class="line"></span><br><span class="line">@ECHO OFF&amp;CLS&amp;color 0a</span><br><span class="line">:HeadStart</span><br><span class="line">ECHO=</span><br><span class="line">ECHO= =-=-=-=-=-=选择开启或关闭=-=-=-=-=-=</span><br><span class="line">ECHO= 1、开启sqlserver的6个相关服务</span><br><span class="line">ECHO= 2、关闭sqlserver的6个相关服务</span><br><span class="line">ECHO= 9、退出</span><br><span class="line">ECHO= =-=-=-=-==-=-=-=-==-=-=-=-==-=-=-=</span><br><span class="line">ECHO=</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>/p ID= 请选择：</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;1&quot;</span> (</span><br><span class="line">	::数据库引擎</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlserver***</span><br><span class="line">	net start mssqlserver</span><br><span class="line">	::远程MSSMS管理</span><br><span class="line">	<span class="built_in">echo</span>=***打开sqlserveragent***</span><br><span class="line">	net start sqlserveragent</span><br><span class="line">	::全文索引程序，一般mssqlserver服务启动后就会级联开启该服务</span><br><span class="line">	<span class="built_in">echo</span>=***打开mssqlfdlauncher***</span><br><span class="line">	net start mssqlfdlauncher</span><br><span class="line">	::分布式事务</span><br><span class="line">	<span class="built_in">echo</span>=***打开msdtc***</span><br><span class="line">	net start msdtc</span><br><span class="line">	::备份还原数据库用的</span><br><span class="line">	<span class="built_in">echo</span>=***打开SQLWriter***</span><br><span class="line">	net start SQLWriter</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***需要时候自己添加命令net start MSSQLServerADHelper100***</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;2&quot;</span> (</span><br><span class="line">	::MSSQLServerADHelper100是帮助服务，通常情况下不需要手动管理</span><br><span class="line">	<span class="built_in">echo</span>=***关闭MSSQLServerADHelper100***</span><br><span class="line">	net stop MSSQLServerADHelper100</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlfdlauncher***</span><br><span class="line">	net stop mssqlfdlauncher</span><br><span class="line">	<span class="built_in">echo</span>=***关闭msdtc***</span><br><span class="line">	net stop msdtc</span><br><span class="line">	<span class="built_in">echo</span>=***关闭SQLWriter***</span><br><span class="line">	net stop SQLWriter</span><br><span class="line">	<span class="built_in">echo</span>=***关闭sqlserveragent***</span><br><span class="line">	net stop sqlserveragent</span><br><span class="line">	<span class="built_in">echo</span>=***关闭mssqlserver***</span><br><span class="line">	net stop mssqlserver /y</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%id%&quot;</span>==<span class="string">&quot;9&quot;</span> <span class="built_in">exit</span></span><br><span class="line">pause</span><br><span class="line">Goto HeadStart</span><br></pre></td></tr></table></figure>

<h2 id="相关的6个服务"><a href="#相关的6个服务" class="headerlink" title="相关的6个服务"></a>相关的6个服务</h2><ul>
<li><p>服务名：mssqlserver</p>
<p>显示名：SQL Server(MSSQLSERVER)服务，SQLServer服务实例，主要服务，只有开启了这个你才能使用Microsoft SQLServer Management Studio连接该数据库实例，开启后会级联开启mssqlfdlauncher服务。</p>
</li>
<li><p>服务名：sqlserveragent</p>
<p>显示名：SQL Server 代理 (MSSQLSERVER)</p>
<p>说明：执行作业、监视 SQL Server、激发警报，以及允许自动执行某些管理任务。</p>
</li>
<li><p>服务名：mssqlfdlauncher</p>
<p>显示名：SQL Full-text Filter Daemon Launcher (MSSQLSERVER)</p>
<p>说明：用于启动全文筛选器后台程序进程的服务，该进程将为 SQL Server 全文搜索执行文档筛选和断字。禁用此服务将使 SQL Server 的全文搜索功能不可用。</p>
</li>
<li><p>服务名：msdtc</p>
<p>显示名：Distributed Transaction Coordinator</p>
<p>说明：协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。当一个事务中涉及多个数据源（比如两台sqlserver）服务器，需要MSDTC的协调处理，一般单机可关闭该服务。</p>
</li>
<li><p>服务名：SQLWriter</p>
<p>显示名：SQL Server VSS Writer</p>
<p>说明：sqlwriter是Microsoft SQL Server的编写器服务，允许备份和还原应用程序，以便在Volume Shadow Copy Service（VSS）框架中进行操作，服务器上的所有SQL实例只有一个SQL编写器服务。</p>
</li>
<li><p>服务名：MSSQLServerADHelper100</p>
<p>显示名：SQL Active Directory Helper 服务</p>
</li>
<li><p>服务名：SQLBrowser</p>
<p>显示名：SQL Server Browser</p>
<p>说明：如果一个物理服务器上面有多个SQL Server实例，那么为了确保客户端能访问到正确的实例，所以自SQL Server 2005提供了一个新的Browser服务。如果一台计算机上只有一个实例，且配置为静态端口，则无需启动Browser服务；反之则需要启动。</p>
</li>
</ul>
<h2 id="有关MSSQLServerADHelper启动问题"><a href="#有关MSSQLServerADHelper启动问题" class="headerlink" title="有关MSSQLServerADHelper启动问题"></a>有关MSSQLServerADHelper启动问题</h2><blockquote>
<p>I want to inform that MSSQLServerADHelper service is dynamically started by an instance of SQL Server or Analysis Manager when needed, and is stopped as soon as it has completed its work, we don’t need to start it manually. Additionally, let’s change the service startup account as localsystem account and check whether the error occurs again.</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
        <category>使用技巧</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
        <tag>数据库</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>配置 SSH 连接 Github</title>
    <url>/2021/04/+%E9%85%8D%E7%BD%AESSH%E8%BF%9E%E6%8E%A5Github/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="配置-SSH-连接-Github"><a href="#配置-SSH-连接-Github" class="headerlink" title="配置 SSH 连接 Github"></a>配置 SSH 连接 Github</h2><p>下面默认你已经注册了 Github，为避免麻烦，以下命令均在 <strong>Git bash</strong> 下运行</p>
<ol>
<li><p>配置 git 的登录信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;user name&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;user email&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>&lt;user name&gt; 与 &lt;user email&gt; 填上你注册的 Github 信息</p>
</li>
<li><p>生成密钥 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;&lt;user email&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>注意：</p>
<p>&lt;user email&gt; 与你的注册 Github 的邮箱一致。</p>
<p>命令运行中间会让你输入3次，都可以按 Enter 跳过，最后到 <strong>%HOMEPATH%\.ssh</strong> 中就能看到生成的两个文件（公钥和私钥），命令中也能看到该目录。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/&lt;UserName&gt;/.ssh/id_rsa): #可直接回车</span><br><span class="line">Enter passphrase (empty for no passphrase): #可直接回车</span><br><span class="line">Enter same passphrase again: #可直接回车</span><br><span class="line">Your identification has been saved in /Users/&lt;UserName&gt;/.ssh/id_rsa. #私钥地址</span><br><span class="line">Your public key has been saved in /Users/&lt;UserName&gt;/.ssh/id_rsa.pub. #公钥地址</span><br></pre></td></tr></table></figure></li>
<li><p>访问 <a href="https://github.com/settings/keys">SSH and GPG keys (github.com)</a>，选择 <strong>New SSH key</strong>，<strong>Title</strong> 填个能标志该 SSH 文件来源的，如：老 Dell 笔记本电脑生成。然后主要就是 <strong>Key</strong> 内容了，我们在本机 <strong>Git bash</strong> 命令行下运行下面命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> C:/Users/Singo/.ssh/id_rsa.pub | clip <span class="comment">#记得改成自己生成的公钥文件地址</span></span><br></pre></td></tr></table></figure>

<p>这样就会把你的 pub key 内容复制，你只需要在网页的 <strong>Key</strong> 框下 <strong>Ctrl+V</strong>，然后点击 <strong>Add SSH key</strong>，就能添加完成。</p>
<p>PS：最好不要直接使用 notepad 打开你的公钥 pub 文件并复制，我之前测试使用过这种办法，结果后面连接测试失败了。</p>
</li>
<li><p>运行以下命令进行连接测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>注意：第一次运行会有 <code>Are you sure you want to continue connecting (yes/no)? </code>，需要你填 yes，不能直接 Enter 键跳过，不然就会一直不成功。</p>
<p>成功的信息类似：<code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Dev</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NVM管理node.js版本</title>
    <url>/2022/01/+%E4%BD%BF%E7%94%A8NVM%E7%AE%A1%E7%90%86node.js%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是NVM"><a href="#什么是NVM" class="headerlink" title="什么是NVM"></a>什么是NVM</h2><p>全名<strong>node.js version management</strong>，是一个<strong>node.js的版本管理工具</strong>。通过它可以安装和切换不同版本的 nodejs。</p>
<p>其主要解决不同项目所需node.js版本不一致时管理的麻烦，就比如我弄hexo主题，不同的主题需要的nodejs版本不一致，没有这来管理，我得不停安装卸载nodejs来测试，还要修改环境变量等，十分麻烦，使用这工具就能很轻松管理。</p>
<span id="more"></span>

<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="第一步：卸载你的NodeJs"><a href="#第一步：卸载你的NodeJs" class="headerlink" title="第一步：卸载你的NodeJs"></a>第一步：卸载你的NodeJs</h3><p>将电脑现在装的node进行卸载，最好是删除所有关于node的文件及内容</p>
<h3 id="第二步：安装NVM"><a href="#第二步：安装NVM" class="headerlink" title="第二步：安装NVM"></a>第二步：安装NVM</h3><p>通过Github服务器<a href="https://github.com/coreybutler/nvm-windows/releases">下载安装</a></p>
<p>下载完成后，按照安装操作一步一步安装就好了，很简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置</span><br><span class="line">nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。</span><br><span class="line">Source code(zip)：zip压缩的源码</span><br><span class="line">Sourc code(tar.gz)：tar.gz的源码，一般用于Linux系统</span><br></pre></td></tr></table></figure>

<p>建议下载nvm-setup.zip版本，配置我怕你不会弄弄乱了也不懂改。</p>
<p>打开zip文件，运行exe文件安装，我建议把nvm与node相关都统合在一起，以后好管理，我统一都在<code>C:\Env</code>下，NVM安装地址就填<code>C:\Env\NVM</code>，nodejs安装地址就填<code>C:\Env\nodejs</code>，安装完后你会看到<code>C:\Env</code>目录下有NVM文件夹，但是没有nodejs文件夹，这是因为前面的nodejs地址填的是以后nodejs的访问地址，现在还没有安装并使用nodejs自然就没有。</p>
<h3 id="第三步：测试nvm是否安装成功"><a href="#第三步：测试nvm是否安装成功" class="headerlink" title="第三步：测试nvm是否安装成功"></a>第三步：测试nvm是否安装成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm -v</span><br><span class="line">//version 1.1.6  出现版本号，说明安装成功，接下来就可以进行下面的操作</span><br></pre></td></tr></table></figure>

<h3 id="第四步：安装并控制node版本"><a href="#第四步：安装并控制node版本" class="headerlink" title="第四步：安装并控制node版本"></a>第四步：安装并控制node版本</h3><p>前面完成后，接下来就可以安装并随意切换我们的node版本号了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list available  // 首先可以通过命令来查询我们可以安装的node版本</span><br><span class="line">nvm install 10.5.0  // 安装指定的版本的nodejs</span><br><span class="line">nvm <span class="built_in">ls</span>   // 查看目前已经安装的版本</span><br><span class="line">nvm use 10.5.0  // 使用指定版本的nodejs，需要权限较高，windows下需要管理员权限</span><br></pre></td></tr></table></figure>

<p>可以通过<code>nvm install</code>命令安装多个版本的nodejs，然后通过<code>nvm use</code>命令来切换要是用的版本号。</p>
<p>通过切换版本号后，可以通过<code>node -v</code>命令来检测是否使用成功。</p>
<h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>由于国外的镜像源下载慢，可以使用命令更改为Taobao的源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<h2 id="NVM常用命令"><a href="#NVM常用命令" class="headerlink" title="NVM常用命令"></a>NVM常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm off                     // 禁用node.js版本管理(不卸载任何东西)</span><br><span class="line">nvm on                      // 启用node.js版本管理</span><br><span class="line">nvm install &lt;version&gt;       // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0</span><br><span class="line">nvm uninstall &lt;version&gt;     // 卸载node.js是的命令，卸载指定版本的nodejs，当安装失败时卸载使用</span><br><span class="line">nvm <span class="built_in">ls</span>                      // 显示所有已安装的node.js版本</span><br><span class="line">nvm list available          // 显示可以安装的所有node.js的版本</span><br><span class="line">nvm use &lt;version&gt;           // 切换到使用指定的nodejs版本</span><br><span class="line">nvm v                       // 显示nvm版本</span><br><span class="line">nvm install stable          // 安装最新稳定版</span><br></pre></td></tr></table></figure>

<h2 id="可能遇到问题解决"><a href="#可能遇到问题解决" class="headerlink" title="可能遇到问题解决"></a>可能遇到问题解决</h2><ul>
<li><p>windows 上安装 nvm 后选择 node 版本出现 exit status 1…</p>
<p>问题：nvm install x.x.x 可以安装成功，但无法切换和使用，报错 exit status 1</p>
<p>原因1：把 nvm 安装到了有空格的路径上（D:\Program Files），导致切换失败</p>
<p>解决1：把 nvm 卸载重装到没有空格的路径上（例如：D:\nvm），即可解决问题</p>
<p>原因2：Cmd命令权限不足</p>
<p>解决2：使用 <strong>以管理员身份运行</strong> 运行<code>Cmd</code>程序，然后再运行<code>nvm</code>命令</p>
</li>
<li><p>nvm 在 CMD 中不生效</p>
<p>报错：nvm : 无法将 nvm 项识别为 cmdlet、函数、脚本文件或可运行程序的名称。</p>
<p>意思就是<code>nvm</code>还不是个命令，说明没有配置成功。</p>
<p>原因：当环境变量没配正确时（使用免安装版时需要配置环境变量），重启也不会生效。在确保环境变量配置正确后，重启<code>cmd</code>控制台后会生效。</p>
</li>
<li><p>npm Download failed</p>
<p>有时候安装 node 安装成功之后，会去安装 npm 有时候就会报错 npm 拒绝啥的，具体报错没有记录</p>
<p>解决：使用镜像加速（把镜像加速的那2行加入，重新开 cmd 安装即可）</p>
</li>
<li><p>node 版本安装成功，但是使用时还是之前的版本</p>
<p>如之前安装过node版本 10.15.0，没有卸载，直接安装的 nvm，并用 nvm 安装了 14.18.1 的 node。如下切换成 14.18.1 版本也正常，但是查看 node -v 却还是之前的版本。</p>
<p>解决：<strong>在安装 NVM for Windows 之前，您需要卸载任何现有版本的 node.js，还需要删除任何现有nodejs安装目录</strong>。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/goloving/p/15401739.html">浅析nvm介绍、安装与使用以及遇到的问题解决</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>NVM</tag>
        <tag>npm</tag>
        <tag>nodejs</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core使用EFCore</title>
    <url>/2022/01/+ASP.NETCore%E4%BD%BF%E7%94%A8EFCore/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="ASP-NET-Core分层结构项目里使用EF-Core"><a href="#ASP-NET-Core分层结构项目里使用EF-Core" class="headerlink" title="ASP.NET Core分层结构项目里使用EF Core"></a>ASP.NET Core分层结构项目里使用EF Core</h2><ol>
<li><p>创建一个类库项目，引入需要的包，注意选择与自己项目版本匹配的</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Microsoft.EntityFrameworkCore</span><br><span class="line"><span class="built_in">Install-Package</span> Npgsql.EntityFrameworkCore.PostgreSQL //使用PostgreSQL</span><br><span class="line"><span class="built_in">Install-Package</span> Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure>

<p>注意安装的包版本需要匹配你的框架版本</p>
<p>用的数据库需要什么包，可以看微软官方文档这篇：<a href="https://learn.microsoft.com/zh-cn/ef/core/providers/">数据库提供程序</a></p>
<span id="more"></span></li>
<li><p>建立一个 DbContext</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HolyGrailWarDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HolyGrailWarDbContext</span>(<span class="params">DbContextOptions&lt;HolyGrailWarDbContext&gt; options</span>) :<span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Master&gt; Masters &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MasterId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意构造函数的写法，以及不重写 OnConfiguring 方法</p>
</li>
<li><p>创建一个ASP.NET Core WebApi项目，引入需要的包</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> Microsoft.EntityFrameworkCore</span><br><span class="line"><span class="built_in">Install-Package</span> Npgsql.EntityFrameworkCore.PostgreSQL</span><br><span class="line"><span class="built_in">Install-Package</span> Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure></li>
<li><p>注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strConn = <span class="string">@&quot;Host=localhost;Database=HolyGrailWar;Username=postgres;Password=password&quot;</span>;</span><br><span class="line">services.AddDbContext&lt;HolyGrailWarDbContext&gt;(options =&gt;</span><br><span class="line">    options.UseNpgsql(strConn));</span><br></pre></td></tr></table></figure></li>
<li><p>注入使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MasterController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HolyGrailWarDbContext holyGrailWarDbContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MasterController</span>(<span class="params">HolyGrailWarDbContext holyGrailWarDbContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.holyGrailWarDbContext = holyGrailWarDbContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;/GetMasters&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Master&gt; <span class="title">GetMasters</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> holyGrailWarDbContext.Masters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPut(<span class="string">&quot;/AddMasters&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">AddMasters</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> master1 = holyGrailWarDbContext.Masters.Add(<span class="keyword">new</span> Master &#123; Name = <span class="string">$&quot;Shirou Emiya&quot;</span> &#125;);</span><br><span class="line">        <span class="keyword">var</span> master2 = holyGrailWarDbContext.Masters.Add(<span class="keyword">new</span> Master &#123; Name = <span class="string">$&quot;Osaka Rin&quot;</span> &#125;);</span><br><span class="line">        <span class="keyword">var</span> master3 = holyGrailWarDbContext.Masters.Add(<span class="keyword">new</span> Master &#123; Name = <span class="string">$&quot;Illyasviel von Einzbern&quot;</span> &#125;);</span><br><span class="line">        holyGrailWarDbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> str = <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">var</span> masters = holyGrailWarDbContext.Masters;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> master <span class="keyword">in</span> masters)</span><br><span class="line">        &#123;</span><br><span class="line">            str += <span class="string">$&quot;ID:<span class="subst">&#123;master.MasterId,<span class="number">4</span>&#125;</span>, Name:<span class="subst">&#123;master.Name&#125;</span> \n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">$&quot;Add masters OK, Now has below masters: \n<span class="subst">&#123;str&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>   上面还没有建立相应的数据库，我们需要使用 EF Core 的迁移命令进行</p>
<ol>
<li><p>把 ASP.NET Core WebApi 项目设为启动项目，将 “程序包管理控制台” 的默认项目设为 DbContext 所在类库</p>
</li>
<li><p>在“程序包管理控制台”，运行命令<code>Add-Migration</code>，获得迁移脚本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Add-Migration</span> InitialCreate //InitialCreate是迁移版本名称，可以自定义</span><br></pre></td></tr></table></figure></li>
<li><p>在“程序包管理控制台”，运行命令<code>Update-Database</code>，更新数据库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Update-Database</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看数据库，可以看到相应的数据库与表都建立的，使用前面添加的控制器测试使用</p>
</li>
</ol>
<p>在运行<code>Add-Migration</code>与<code>Update-Database</code>命令时候，可能有一些问题，按照错误查找解决办法即可</p>
<p>下面列举我遇到过的问题：</p>
<ul>
<li><p>问题：<code>The EF Core tools version &#39;3.1.21&#39; is older than that of the runtime &#39;3.1.22&#39;. Update the tools for the latest features and bug fixes.</code></p>
<p>解决：更新<code>Microsoft.EntityFrameworkCore.Tools</code>到相应版本</p>
</li>
<li><p>问题：<code>Update-Database</code>，<code>Add-Migration</code>生成的脚本报错</p>
<p>解决：没有<code>Microsoft.EntityFrameworkCore.Relational</code>包，一般引入相应的SQL包就会包含了，如Postgresql的包<code>Npgsql.EntityFrameworkCore.PostgreSQL</code>就包含，实在没有就自己安装</p>
</li>
<li><p>问题：<code>Add-Migration</code>时错误，<code>More than one DbContext was found. Specify which one to use. Use the &#39;-Context&#39; parameter for PowerShell commands and the &#39;--context&#39; parameter for dotnet commands.</code></p>
<p>解决：先在 ASP.NET Core WebApi 项目注册需要用的 DbContext，然后使用参数 ‘-Context’ 指定DbContext，如现在有两个 DbContext（<code>FirstholyGrailWarDbContext</code>与<code>SecondholyGrailWarDbContext</code>）都要用，则依下步骤</p>
<p>注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strConn = <span class="string">@&quot;Host=localhost;Database=HolyGrailWar;Username=postgres;Password=password&quot;</span>;</span><br><span class="line">services.AddDbContext&lt;FirstholyGrailWarDbContext&gt;(options =&gt;</span><br><span class="line">    options.UseNpgsql(strConn));</span><br><span class="line">services.AddDbContext&lt;SecondholyGrailWarDbContext&gt;(options =&gt;</span><br><span class="line">    options.UseNpgsql(strConn));</span><br></pre></td></tr></table></figure>

<p>迁移，有多个 DbContext 时两个命令都需要指定要用的 DbContext，其他相关命令也是</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">//FirstholyGrailWarDbContext</span><br><span class="line"><span class="built_in">Add-Migration</span> InitialCreate <span class="literal">-Context</span> FirstholyGrailWarDbContext</span><br><span class="line"><span class="built_in">Update-Database</span> <span class="literal">-Context</span> FirstholyGrailWarDbContext</span><br><span class="line"></span><br><span class="line">//SecondholyGrailWarDbContext</span><br><span class="line"><span class="built_in">Add-Migration</span> InitialCreate <span class="literal">-Context</span> SecondholyGrailWarDbContext</span><br><span class="line"><span class="built_in">Update-Database</span> <span class="literal">-Context</span> SecondholyGrailWarDbContext</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="慎用AddDbContextPool"><a href="#慎用AddDbContextPool" class="headerlink" title="慎用AddDbContextPool"></a>慎用AddDbContextPool</h2><h3 id="AddDbContext与AddDbContextPool"><a href="#AddDbContext与AddDbContextPool" class="headerlink" title="AddDbContext与AddDbContextPool"></a>AddDbContext与AddDbContextPool</h3><p>DbContext 是非线程安全的，我们不能在同一<code>DbContext</code>实例上同时运行多个操作（Add、Update、Delete等），因此一般的做法就是在需要使用的时候就创建一个<code>DbContext</code>，待用完后就销毁掉，这就是<code>AddDbContext</code>的做法。</p>
<p>但是实际上我们是可以重用已创建的<code>DbContext</code>实例的，只是需要注意该<code>DbContext</code>前面的操作都需要已经完成了，这就是<code>AddDbContextPool</code>的做法。<code>AddDbContextPool</code>会保留多个已创建的<code>DbContext</code>且现在已经没被使用的实例到池，当请求需要<code>DbContext</code>时也会倾向于返回池里已有的<code>DbContext</code>多过创建一个新的。</p>
<h3 id="使用AddDbContextPool问题"><a href="#使用AddDbContextPool问题" class="headerlink" title="使用AddDbContextPool问题"></a>使用AddDbContextPool问题</h3><p><code>AddDbContextPool</code>的做法看似很美好，能够避免<code>DbContext</code>实例创建时的性能消耗，但是实际使用中还是有些坑的：</p>
<ol>
<li><p>用了<code>AddDbContextPool</code>那么你的<code>DbContext</code>就难以注入其他服务，因为使用<code>AddDbContextPool</code>创建的<code>DbContext</code>类似于 singleton 服务，导致只有同为 singleton 的服务才能注入。</p>
</li>
<li><p>有很多 ADO.NET 的提供者也实现了数据库连接池的机制，有可能于其冲突。</p>
</li>
<li><p>有其他坑会导致一些奇怪的问题，如</p>
<p><a href="https://www.cnblogs.com/dudu/p/10398225.html">EF Core 小坑：DbContextPool 会引起数据库连接池连接耗尽</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/400289286">关于EFCore的上下文池DbContextPool和延迟加载LazyLoader冲突的探索</a></p>
</li>
</ol>
<h3 id="使用带“小上下文”策略的AddDbContext方法"><a href="#使用带“小上下文”策略的AddDbContext方法" class="headerlink" title="使用带“小上下文”策略的AddDbContext方法"></a>使用带“小上下文”策略的AddDbContext方法</h3><p>鉴于上面<code>AddDbContextPool</code>的问题，推荐假如自认不能 hold 住的还是使用<code>AddDbContext</code>的方法，虽然性能差点，但是对于非高并发请求（1000req/1s以上）的应用，使用<code>AddDbContext</code>就足够了。</p>
<p>假如觉得不满足的话，可以使用“小DbContext”的策略，即把一个DbContext分拆成多个DbContext，如本身一个大 DbContext 里有100个 DbSet，但是拆分成20个 DbContext，这样平均一个 DbContext 就4个 DbSet，创建的消耗自然减少，使用多个 DbContext 步骤如下：</p>
<ol>
<li><p>首先需要自己分割 DbContext，假设已分割完了有两个<code>FirstDbContext</code>、<code>SecondDbContext</code></p>
</li>
<li><p>注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddDbContext&lt;FirstDbContext&gt;(options =&gt; options.UseSqlServer(strConnString));</span><br><span class="line">services.AddDbContext&lt;SecondDbContext&gt;(options =&gt; options.UseSqlServer(strConnString));</span><br></pre></td></tr></table></figure></li>
<li><p>使用时注入，假设只注入FirstDbContext</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> FirstDbContext firstDbContext;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlogController</span>(<span class="params">FirstDbContext firstDbContext</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstDbContext = firstDbContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这种做法是 DDD 设计原则，把一个大的根据业务分拆成小的，也很符合微服务的概念。不过难点就在于如何拆分，分得不好，就会导致明明以前只需要一个 DbContex 就能干的，结果现在需要多个 DbContex，不但麻烦了，性能可能还降低的。</p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>EF Core</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core使用JWT</title>
    <url>/2022/02/+ASP.NETCore%E4%BD%BF%E7%94%A8JWT/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="有关JWT的基础"><a href="#有关JWT的基础" class="headerlink" title="有关JWT的基础"></a>有关JWT的基础</h2><p>看这文章之前需要先对JWT有了解，不过这部分已经有很多很好的文章，这边我就不再叙述，你可以看如 <a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权4:JwtBearer认证</a> 前面的介绍。</p>
<h2 id="ASP-NET-Core使用JWT"><a href="#ASP-NET-Core使用JWT" class="headerlink" title="ASP.NET Core使用JWT"></a>ASP.NET Core使用JWT</h2><p>这里我按照正常项目那样，分成两个项目，JWT.Server项目负责生成JWT，JWT.DemoApi则负责提供Api接口服务对于受限接口会验证JWT。</p>
<span id="more"></span>

<h3 id="JWT-Server生成JWT"><a href="#JWT-Server生成JWT" class="headerlink" title="JWT.Server生成JWT"></a>JWT.Server生成JWT</h3><ol>
<li><p>新建ASP.NET Core WebApi项目，我这里使用了3.1版本</p>
</li>
<li><p>nuget安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 需要根据自己的.net core版本选择相应版本</span><br><span class="line">Install-Package Microsoft.AspNetCore.Authentication.JwtBearer</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>appsettings.json</code>中添加上JWT相关配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Jwt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//密钥，需要大于等于16个字符，生产中密钥当然不能如下面这么简单</span></span><br><span class="line">  <span class="attr">&quot;Secret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789@qwerasdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//签发者</span></span><br><span class="line">  <span class="attr">&quot;Iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hushitong.github.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//使用者</span></span><br><span class="line">  <span class="attr">&quot;Aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//设置过期时间</span></span><br><span class="line">  <span class="attr">&quot;ExpireSeconds&quot;</span><span class="punctuation">:</span> <span class="number">300</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建<code>JWTController</code>，添加生成JWT相关代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">JWT.Server.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">JWTController</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Authenticate</span>(<span class="params"><span class="built_in">string</span> userName, <span class="built_in">string</span> pwd</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实际项目这里应该做登陆验证，这里就写死了</span></span><br><span class="line">            <span class="keyword">if</span> (userName == <span class="string">&quot;admin&quot;</span> &amp;&amp; pwd == <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> jwtConfig = configuration.GetSection(<span class="string">&quot;Jwt&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定义签名使用的密钥，以及使用Hmacsha256签名算法</span></span><br><span class="line">                <span class="keyword">var</span> securityKey = <span class="keyword">new</span> SigningCredentials(<span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Secret&quot;</span>))), SecurityAlgorithms.HmacSha256);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//有效载荷</span></span><br><span class="line">                <span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Iss,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Aud,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;1&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                SecurityToken securityToken = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">                    signingCredentials: securityKey,</span><br><span class="line">                    expires: DateTime.Now.AddSeconds(jwtConfig.GetValue&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;ExpireSeconds&quot;</span>)), <span class="comment">//过期时间</span></span><br><span class="line">                    claims: claims</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">//生成jwt令牌</span></span><br><span class="line">                <span class="keyword">return</span> Content(<span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(securityToken));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试访问接口，可获得JWT</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODA4NjU0fQ.aqdRxdA9CakK_jrz-J3jTn2Rgu_2WkriHtLCJC61IcM</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JWT-DemoApi使用JWT验证"><a href="#JWT-DemoApi使用JWT验证" class="headerlink" title="JWT.DemoApi使用JWT验证"></a>JWT.DemoApi使用JWT验证</h3><ol>
<li><p>新建ASP.NET Core WebApi项目，我这里使用了3.1版本</p>
</li>
<li><p>nuget安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 需要根据自己的.net core版本选择相应版本</span><br><span class="line">Install-Package Microsoft.AspNetCore.Authentication.JwtBearer</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>appsettings.json</code>中添加上JWT相关配置，注意配置内容与JWT.Server里的基本一致，只是少了<code>ExpireSeconds</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Jwt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//密钥，需要大于等于16个字符，生产中密钥当然不能如下面这么简单</span></span><br><span class="line">  <span class="attr">&quot;Secret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789@qwerasdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//签发者</span></span><br><span class="line">  <span class="attr">&quot;Iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hushitong.github.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//使用者</span></span><br><span class="line">  <span class="attr">&quot;Aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Startup.ConfigureServices</code>里注册JWT</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得使用的密钥</span></span><br><span class="line"><span class="keyword">var</span> jwtConfig = Configuration.GetSection(<span class="string">&quot;Jwt&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> signingKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Secret&quot;</span>)));</span><br><span class="line"><span class="comment">//认证参数</span></span><br><span class="line">services.AddAuthentication(<span class="string">&quot;Bearer&quot;</span>)</span><br><span class="line">    .AddJwtBearer(o =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        o.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">        &#123;</span><br><span class="line">            ValidateIssuerSigningKey = <span class="literal">true</span>,<span class="comment">//是否验证签名,不验证的画可以篡改数据，不安全</span></span><br><span class="line">            IssuerSigningKey = signingKey,<span class="comment">//使用的密钥</span></span><br><span class="line">            ValidateIssuer = <span class="literal">true</span>,<span class="comment">//是否验证签发者，就是验证载荷中的Iss是否对应ValidIssuer参数</span></span><br><span class="line">            ValidIssuer = jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>),<span class="comment">//签发者</span></span><br><span class="line">            ValidateAudience = <span class="literal">true</span>,<span class="comment">//是否验证使用者，就是验证载荷中的Aud是否对应ValidAudience参数</span></span><br><span class="line">            ValidAudience = jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>),<span class="comment">//使用者</span></span><br><span class="line">            ValidateLifetime = <span class="literal">true</span>,<span class="comment">//是否验证过期时间，过期了就拒绝访问</span></span><br><span class="line">            ClockSkew = TimeSpan.Zero,<span class="comment">//这个是缓冲过期时间，也就是说，即使我们配置了过期时间，这里也要考虑进去，过期时间+缓冲，默认好像是7分钟，你可以直接设置为0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>确保<code>Startup.Configure</code>方法中添加 了 <code>app.UseAuthorization()</code>及<code>app.UseAuthentication()</code>，没有就加上</p>
<p>注意：<code>app.UseAuthentication()</code>你不加应用也不会报错，但是后续请求需要JWT验证的接口时会一直报401错误。</p>
</li>
<li><p>新建<code>JWTTestController</code>，添加相关测试代码，需要JWT验证的需要在Action上加上特性<code>[Authorize]</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JWTTestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不需要验证JWT</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithoutAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只验证JWT是否通过</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">Authorize</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用HttpContext.User.Claims可以获得当前用户Payload里的信息</span></span><br><span class="line">        HttpContext.User.Claims.ToList().ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证JWT是否通过同时还得验证其payload中是否由符合SuperAdmin的Role</span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">Authorize(Roles =<span class="string">&quot;SuperAdmin&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">GetWithRoleAuth</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;访问成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JWT测试"><a href="#JWT测试" class="headerlink" title="JWT测试"></a>JWT测试</h3><p>准备工作：运行JWT.Server，获得JWT</p>
<h4 id="访问JWT-DemoApi请求头不带JWT"><a href="#访问JWT-DemoApi请求头不带JWT" class="headerlink" title="访问JWT.DemoApi请求头不带JWT"></a>访问JWT.DemoApi请求头不带JWT</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br><span class="line"></span><br><span class="line">-- 请求：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br></pre></td></tr></table></figure>

<p>可以看到添加了<code>[Authorize]</code>特性的接口都返回401 <em>(401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息)</em></p>
<h4 id="访问JWT-DemoApi请求头带JWT"><a href="#访问JWT-DemoApi请求头带JWT" class="headerlink" title="访问JWT.DemoApi请求头带JWT"></a>访问JWT.DemoApi请求头带JWT</h4><p>使用Postman或其他你顺手的工具，在请求头加上<code>Authorization: Bearer JWTString</code>，即可使用JWT测试，我这里使用的时Swagger带JWT的办法。</p>
<p>结果如下：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line"> curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2h1c2hpdG9uZy5naXRodWIuaW8iLCJhdWQiOiJhcGkiLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6IjEiLCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dzLzIwMDgvMDYvaWRlbnRpdHkvY2xhaW1zL3JvbGUiOlsic3lzdGVtIiwiYWRtaW4iXSwiZXhwIjoxNjQ0ODM0NzkwfQ.-AoGFQAVjkbkEkPPrMd3f6a6K_v-QKIDJNGYb0S7xgU&#x27;</span></span><br><span class="line">-- 响应：</span><br><span class="line">  Code：403</span><br><span class="line">  Error: response status is 403</span><br></pre></td></tr></table></figure>

<p>请求头添加了JWT参数后，<code>GetWithAuth</code>接口成功，但是<code>GetWithRoleAuth</code>却是返回403 <em>(403 forbidden，表示对请求资源的访问被服务器拒绝)</em> ，这是因为该接口有特性<code>[Authorize(Roles =&quot;SuperAdmin&quot;)]</code>限定了需要有SuperAdmin角色才能访问，而前面JWT.Server所发放的JWT里并不包含该角色，想要测试通过，只需要在JWT.Server发放JWT时payload里添加上SuperAdmin角色，重新生成JWT再测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有效载荷</span></span><br><span class="line"><span class="keyword">var</span> claims = <span class="keyword">new</span> Claim[] &#123;</span><br><span class="line">    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Iss,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Iss&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Claim(JwtRegisteredClaimNames.Aud,jwtConfig.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Aud&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Name,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,<span class="string">&quot;1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;system&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;admin&quot;</span>),</span><br><span class="line">    <span class="comment">//这里添加SuperAdmin角色</span></span><br><span class="line">    <span class="keyword">new</span> Claim(ClaimTypes.Role,<span class="string">&quot;SuperAdmin&quot;</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="访问JWT-DemoApi请求头带过期的JWT"><a href="#访问JWT-DemoApi请求头带过期的JWT" class="headerlink" title="访问JWT.DemoApi请求头带过期的JWT"></a>访问JWT.DemoApi请求头带过期的JWT</h4><p>我们获得JWT后，等待300秒（前面设定的）让其过期，然后测试，结果和 <a href="#%E8%AE%BF%E9%97%AEJWT-DemoApi%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%B8%A6JWT">访问JWT.DemoApi请求头不带JWT</a> 一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithoutAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：200</span><br><span class="line">  Response body：访问成功</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br><span class="line"></span><br><span class="line">-- 响应：</span><br><span class="line">curl -X <span class="string">&#x27;GET&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;https://localhost:5001/api/JWTTest/GetWithRoleAuth&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept: */*&#x27;</span> \</span><br><span class="line">-- 响应：</span><br><span class="line">  Code：401</span><br><span class="line">  Error: response status is 401</span><br></pre></td></tr></table></figure>

<h2 id="TokenValidationParameters常用内容说明"><a href="#TokenValidationParameters常用内容说明" class="headerlink" title="TokenValidationParameters常用内容说明"></a>TokenValidationParameters常用内容说明</h2><p><code>TokenValidationParameters</code>是和token验证有关的参数配置，进行token验证时需要用到，下面是我对着该类写常用内容说明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenValidationParameters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Token最大占用空间：250 KB (kilobytes).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> DefaultMaximumTokenSizeInBytes = <span class="number">256000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的缓冲过期时间为：300seconds (5 minutes).</span></span><br><span class="line">    <span class="comment">// 真实过期时间 = 过期时间 + 缓冲过期时间</span></span><br><span class="line">    [<span class="meta">DefaultValue(300)</span>]</span><br><span class="line">    <span class="keyword">public</span> TimeSpan ClockSkew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否要求token必须包含过期时间。默认为true，即Jwt的Payload部分必须包含exp且具有有效值。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireExpirationTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否验证token是否在有效期内，即验证Jwt的Payload部分的nbf和exp。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateLifetime</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否必须有签名部分，默认为true</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireSignedTokens;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于验证Jwt签名的密钥。</span></span><br><span class="line">    <span class="comment">//对于对称加密来说，加签和验签都是使用的同一个密钥；</span></span><br><span class="line">    <span class="comment">//对于非对称加密来说，使用私钥加签，然后使用公钥验签。</span></span><br><span class="line">    <span class="keyword">public</span> SecurityKey IssuerSigningKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 受众</span></span><br><span class="line">    <span class="comment">//是否必须有受众，默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> RequireAudience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否验证受众，默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateAudience</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的受众，默认为null。ValidateAudience为true时，对比该值与Jwt的Payload部分的aud。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ValidAudience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的受众列表，可以指定多个受众,，默认为null。</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; ValidAudiences;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 签发者</span></span><br><span class="line">    <span class="comment">//是否验证签发者。默认为true。</span></span><br><span class="line">    [<span class="meta">DefaultValue(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ValidateIssuer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的签发者，默认为null，ValidateIssuer为true时，对比该值与Jwt的Payload部分的iss。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ValidIssuer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效的签发者列表，可以指定多个签发者,，默认为null。</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; ValidIssuers;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当token验证通过后，是否保存到Microsoft.AspNetCore.Authentication.AuthenticationProperties，默认false。</span></span><br><span class="line">    <span class="comment">//该操作发生在执行完JwtBearerEvents.TokenValidated之后。</span></span><br><span class="line">    <span class="comment">//想在后面代码里使用HttpContext.User.Claims可以获得当前用户Payload里的信息的话，需要设置true</span></span><br><span class="line">    [<span class="meta">DefaultValue(false)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SaveSigninToken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，可以看到其默认设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TokenValidationParameters</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RequireExpirationTime = <span class="literal">true</span>;</span><br><span class="line">        RequireSignedTokens = <span class="literal">true</span>;</span><br><span class="line">        RequireAudience = <span class="literal">true</span>;</span><br><span class="line">        SaveSigninToken = <span class="literal">false</span>;</span><br><span class="line">        ValidateActor = <span class="literal">false</span>;</span><br><span class="line">        ValidateAudience = <span class="literal">true</span>;</span><br><span class="line">        ValidateIssuer = <span class="literal">true</span>;</span><br><span class="line">        ValidateIssuerSigningKey = <span class="literal">false</span>;</span><br><span class="line">        ValidateLifetime = <span class="literal">true</span>;</span><br><span class="line">        ValidateTokenReplay = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JwtBearerEvents"><a href="#JwtBearerEvents" class="headerlink" title="JwtBearerEvents"></a>JwtBearerEvents</h2><p>在验证JWT时，<code>Microsoft.AspNetCore.Authentication.JwtBearer</code>同时提供了一些额外事件来提供更有力的支持。</p>
<h3 id="OnMessageReceived事件"><a href="#OnMessageReceived事件" class="headerlink" title="OnMessageReceived事件"></a>OnMessageReceived事件</h3><p>假设我们的接口会接受网页与App端请求，网页使用Cookies保存JWT信息，而App使用请求头。</p>
<p>那我们需要在请求头中获得不了JWT信息时，再尝试去Cookie中获取，我们可以使用<code>OnMessageReceived</code>事件解决该需求。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册时添加OnMessageReceived</span></span><br><span class="line">services.AddAuthentication(<span class="string">&quot;Bearer&quot;</span>).AddJwtBearer(o =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//省略一些设置</span></span><br><span class="line">    </span><br><span class="line">    o.Events = <span class="keyword">new</span> JwtBearerEvents()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该事件会在收到请求在验证JWT前触发</span></span><br><span class="line">        OnMessageReceived = context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//假如在Header中没有包含JWT的参数，那就到Cookies去找</span></span><br><span class="line">            <span class="keyword">if</span> (!context.Request.Headers.ContainsKey(<span class="string">&quot;Authorization&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获取到Cookies中的access_token，后续验证使用该token，并且在控制台输出</span></span><br><span class="line">                context.Token = context.Request.Cookies[<span class="string">&quot;access_token&quot;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个接口，在Cookies中添加access_token</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">SetCookiesToken</span>(<span class="params"><span class="built_in">string</span> access_token</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HttpContext.Response.Cookies.Append(<span class="string">&quot;access_token&quot;</span>, access_token);</span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">&quot;设置Cookies成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由JWT.Server获得JWT后，先访问<code>SetCookiesToken</code>接口设置token，然后你就不需要再在请求头中添加JWT参数，同样可以访问需要验证接口，结果同 <a href="#%E8%AE%BF%E9%97%AEJWT.DemoApi%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%B8%A6JWT">访问JWT.DemoApi请求头带JWT</a></p>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><p>通过查看<code>Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerEvents</code>，发现除了<code>OnMessageReceived</code>事件外，还提供了如下几个事件：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.AspNetCore.Authentication.JwtBearer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specifies events which the Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler invokes to enable developer control over the authentication process.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JwtBearerEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Invoked if exceptions are thrown during request processing. The exceptions will be re-thrown after this event unless suppressed.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;AuthenticationFailedContext, Task&gt; OnAuthenticationFailed</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked if Authorization fails and results in a Forbidden response</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;ForbiddenContext, Task&gt; OnForbidden</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked when a protocol message is first received.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;MessageReceivedContext, Task&gt; OnMessageReceived</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked after the security token has passed validation and a ClaimsIdentity has been generated.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;TokenValidatedContext, Task&gt; OnTokenValidated</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked before a challenge is sent back to the caller.</span></span><br><span class="line">        <span class="keyword">public</span> Func&lt;JwtBearerChallengeContext, Task&gt; OnChallenge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制JWT失效"><a href="#强制JWT失效" class="headerlink" title="强制JWT失效"></a>强制JWT失效</h2><p>使用JWT本身是有一个问题的，那就是JWT本身在过期时间前都是有效的，这就会导致一些问题，如：账号被封后仍然能用，账号下线后实际其JWT仍可能被其他人利用，账号权限更改后不能实时生效等。</p>
<p>有一些其他办法解决该问题，我这里提供其中一种办法，就是每个用户新对应一个JWTGenerations字段（int类型，从1开始，写入数据库）</p>
<ul>
<li><p>签发端：</p>
<p>在JWT的Payload部分添加一个新字段<code>Generations</code>，其值为最新的JWTGenerations值。</p>
</li>
<li><p>服务端：</p>
<p>验证JWT时，同时拿其<code>Generations</code>与最新的JWTGenerations值比较，只要小于最新的JWTGenerations值，那判定该JWT失效，让其重新登陆。</p>
</li>
</ul>
<p>每当进行使该用户JWT失效的操作（如：用户登陆、用户登出、用户被封等）时，让该用户JWTGenerations值+1。</p>
<p>JWTGenerations值在可以使用Redis等缓存保存以提升速度，然后每过10秒左右（时间根据实际自己定）主动去数据库拉取最新数据，也可以在进行使该用户JWT失效的操作后主动更新该信息都可以。</p>
<p><strong>注意</strong>：该方案会造成只允许一个账号只能在一端登陆，其他端会被下线，需要其他办法再支持。</p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p><a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权4:JwtBearer认证</a></p>
<p><a href="https://www.cnblogs.com/7tiny/p/11019698.html">asp.net core 集成JWT（二）token的强制失效，基于策略模式细化api权限</a></p>
<p><a href="https://www.cnblogs.com/xiaoxiaotank/p/15882735.html">理解ASP.NET Core - 基于JwtBearer的身份认证(Authentication) </a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>JWT</tag>
        <tag>EF Core</tag>
        <tag>Auth</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore使用Swagger</title>
    <url>/2022/01/+ASP.NETCore%E4%BD%BF%E7%94%A8MiniProfiler/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是-MiniProfiler"><a href="#什么是-MiniProfiler" class="headerlink" title="什么是 MiniProfiler"></a>什么是 MiniProfiler</h2><p><a href="https://miniprofiler.com/">MiniProfiler</a> 是一款针对 .NET、Ruby、Go 与 Node.js 的性能分析的轻量级程序。可以对一个页面本身，及该页面通过 <strong>直接引用、Ajax、Iframe</strong> 形式访问的其它页面进行监控，监控内容包括数据库内容，并可以显示数据库访问的 SQL（支持 EF、EF Core 等 ）。并且以很友好的方式展现在页面上。</p>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>nuget 安装对应包</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Package</span> MiniProfiler.AspNetCore.Mvc</span><br></pre></td></tr></table></figure></li>
<li><p>到 <code>Startup.ConfigureServices</code> 中注册</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册MiniProfiler</span></span><br><span class="line">services.AddMiniProfiler(options =&gt;</span><br><span class="line">  <span class="comment">//配置MiniProfiler的路由基础路径，按照当前配置，你可以使用&quot;/profiler/results&quot;来访问分析报告</span></span><br><span class="line">  options.RouteBasePath = <span class="string">&quot;/profiler&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>Startup.Configure</code> 方法中，启用 MiniProfiler 服务</p>
   <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用MiniProfiler服务</span></span><br><span class="line">app.UseMiniProfiler();</span><br></pre></td></tr></table></figure></li>
<li><p>此时启动项目，随意测试请求 Api，然后我们就能通过 “/profiler/results” 地址访问到 MiniProfiler 提供的分析报告页面，可以看到类似表格</p>
<table>
<thead>
<tr>
<th align="left">duration (ms)</th>
<th align="right">with children (ms)</th>
<th align="right">from start (ms)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://localhost:5000/WeatherForecast">http://localhost:5000/WeatherForecast</a></td>
<td align="right">48.1</td>
<td align="right">72.4</td>
<td>+0.6</td>
</tr>
<tr>
<td align="left">MiniProfiler Init</td>
<td align="right">2.8</td>
<td align="right">7.9</td>
<td>+3.7</td>
</tr>
<tr>
<td align="left">Authorize</td>
<td align="right">1.1</td>
<td align="right">1.1</td>
<td>+5.0</td>
</tr>
<tr>
<td align="left">Get Profiler IDs</td>
<td align="right">3.3</td>
<td align="right">3.3</td>
<td>+7.1</td>
</tr>
<tr>
<td align="left">Set Headers</td>
<td align="right">0.7</td>
<td align="right">0.7</td>
<td>+10.5</td>
</tr>
<tr>
<td align="left">Action: UseMiniProfiler.Controllers.WeatherForecastController.Get</td>
<td align="right">4.6</td>
<td align="right">16.4</td>
<td>+52.7</td>
</tr>
<tr>
<td align="left">Action Filter (Execing): UnsupportedContentTypeFilter</td>
<td align="right">0.7</td>
<td align="right">0.7</td>
<td>+54.6</td>
</tr>
<tr>
<td align="left">Action Filter (Execing): ModelStateInvalidFilter</td>
<td align="right">0.0</td>
<td align="right">0.0</td>
<td>+55.4</td>
</tr>
<tr>
<td align="left">Controller Action: UseMiniProfiler.Controllers.WeatherForecastController.Get</td>
<td align="right">2.4</td>
<td align="right">2.4</td>
<td>+55.9</td>
</tr>
<tr>
<td align="left">Action Filter (Execed): ModelStateInvalidFilter</td>
<td align="right">0.0</td>
<td align="right">0.0</td>
<td>+58.4</td>
</tr>
<tr>
<td align="left">Action Filter (Execed): UnsupportedContentTypeFilter</td>
<td align="right">0.0</td>
<td align="right">0.0</td>
<td>+58.5</td>
</tr>
<tr>
<td align="left">Result Filter (Execing): ClientErrorResultFilter</td>
<td align="right">0.0</td>
<td align="right">0.0</td>
<td>+58.8</td>
</tr>
<tr>
<td align="left">Object: IEnumerable`1</td>
<td align="right">8.7</td>
<td align="right">8.7</td>
<td>+60.1</td>
</tr>
<tr>
<td align="left">Result Filter (Execed): ClientErrorResultFilter</td>
<td align="right">0.0</td>
<td align="right">0.0</td>
<td>+68.9</td>
</tr>
</tbody></table>
</li>
<li><p>更加具体的使用可以参考官方文档：<a href="https://miniprofiler.com/dotnet/">https://miniprofiler.com/dotnet/</a></p>
</li>
</ol>
<h3 id="AddMiniProfiler的一些选项说明"><a href="#AddMiniProfiler的一些选项说明" class="headerlink" title="AddMiniProfiler的一些选项说明"></a>AddMiniProfiler的一些选项说明</h3><p>来源：<a href="https://miniprofiler.com/dotnet/AspDotNetCore">https://miniprofiler.com/dotnet/AspDotNetCore</a></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...existing configuration...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note .AddMiniProfiler() returns a IMiniProfilerBuilder for easy intellisense</span></span><br><span class="line">    services.AddMiniProfiler(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// All of this is optional. You can simply call .AddMiniProfiler() for all defaults</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Path to use for profiler URLs, default is /mini-profiler-resources</span></span><br><span class="line">        options.RouteBasePath = <span class="string">&quot;/profiler&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Control storage</span></span><br><span class="line">        <span class="comment">// (default is 30 minutes in MemoryCacheStorage)</span></span><br><span class="line">        <span class="comment">// Note: MiniProfiler will not work if a SizeLimit is set on MemoryCache!</span></span><br><span class="line">        <span class="comment">//   See: https://github.com/MiniProfiler/dotnet/issues/501 for details</span></span><br><span class="line">        (options.Storage <span class="keyword">as</span> MemoryCacheStorage).CacheDuration = TimeSpan.FromMinutes(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Control which SQL formatter to use, InlineFormatter is the default</span></span><br><span class="line">        options.SqlFormatter = <span class="keyword">new</span> StackExchange.Profiling.SqlFormatters.InlineFormatter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) To control authorization, you can use the Func&lt;HttpRequest, bool&gt; options:</span></span><br><span class="line">        <span class="comment">// (default is everyone can access profilers)</span></span><br><span class="line">        options.ResultsAuthorize = request =&gt; MyGetUserFunction(request).CanSeeMiniProfiler;</span><br><span class="line">        options.ResultsListAuthorize = request =&gt; MyGetUserFunction(request).CanSeeMiniProfiler;</span><br><span class="line">        <span class="comment">// Or, there are async versions available:</span></span><br><span class="line">        options.ResultsAuthorizeAsync = <span class="keyword">async</span> request =&gt; (<span class="keyword">await</span> MyGetUserFunctionAsync(request)).CanSeeMiniProfiler;</span><br><span class="line">        options.ResultsAuthorizeListAsync = <span class="keyword">async</span> request =&gt; (<span class="keyword">await</span> MyGetUserFunctionAsync(request)).CanSeeMiniProfilerLists;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional)  To control which requests are profiled, use the Func&lt;HttpRequest, bool&gt; option:</span></span><br><span class="line">        <span class="comment">// (default is everything should be profiled)</span></span><br><span class="line">        options.ShouldProfile = request =&gt; MyShouldThisBeProfiledFunction(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Profiles are stored under a user ID, function to get it:</span></span><br><span class="line">        <span class="comment">// (default is null, since above methods don&#x27;t use it by default)</span></span><br><span class="line">        options.UserIdProvider =  request =&gt; MyGetUserIdFunction(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Swap out the entire profiler provider, if you want</span></span><br><span class="line">        <span class="comment">// (default handles async and works fine for almost all applications)</span></span><br><span class="line">        options.ProfilerProvider = <span class="keyword">new</span> MyProfilerProvider();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) You can disable &quot;Connection Open()&quot;, &quot;Connection Close()&quot; (and async variant) tracking.</span></span><br><span class="line">        <span class="comment">// (defaults to true, and connection opening/closing is tracked)</span></span><br><span class="line">        options.TrackConnectionOpenClose = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) Use something other than the &quot;light&quot; color scheme.</span></span><br><span class="line">        <span class="comment">// (defaults to &quot;light&quot;)</span></span><br><span class="line">        options.ColorScheme = StackExchange.Profiling.ColorScheme.Auto;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Optionally change the number of decimal places shown for millisecond timings.</span></span><br><span class="line">        <span class="comment">// (defaults to 2)</span></span><br><span class="line">        options.PopupDecimalPlaces = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The below are newer options, available in .NET Core 3.0 and above:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) You can disable MVC filter profiling</span></span><br><span class="line">        <span class="comment">// (defaults to true, and filters are profiled)</span></span><br><span class="line">        options.EnableMvcFilterProfiling = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// ...or only save filters that take over a certain millisecond duration (including their children)</span></span><br><span class="line">        <span class="comment">// (defaults to null, and all filters are profiled)</span></span><br><span class="line">        <span class="comment">// options.MvcFilterMinimumSaveMs = 1.0m;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional) You can disable MVC view profiling</span></span><br><span class="line">        <span class="comment">// (defaults to true, and views are profiled)</span></span><br><span class="line">        options.EnableMvcViewProfiling = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// ...or only save views that take over a certain millisecond duration (including their children)</span></span><br><span class="line">        <span class="comment">// (defaults to null, and all views are profiled)</span></span><br><span class="line">        <span class="comment">// options.MvcViewMinimumSaveMs = 1.0m;</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">// (Optional) listen to any errors that occur within MiniProfiler itself</span></span><br><span class="line">        <span class="comment">// options.OnInternalError = e =&gt; MyExceptionLogger(e);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (Optional - not recommended) You can enable a heavy debug mode with stacks and tooltips when using memory storage</span></span><br><span class="line">        <span class="comment">// It has a lot of overhead vs. normal profiling and should only be used with that in mind</span></span><br><span class="line">        <span class="comment">// (defaults to false, debug/heavy mode is off)</span></span><br><span class="line">        <span class="comment">//options.EnableDebugMode = true;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结合Swagger"><a href="#结合Swagger" class="headerlink" title="结合Swagger"></a>结合Swagger</h2><p>   如何添加 Swagger 支持这里就不说了，默认已经弄好。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>创建 index.html 放在项目根目录，该文件会作为 Swagger 自定义首页，并在 VS 里右键该文件设置为 <strong>”嵌入的资源“</strong>。</p>
<p>html 内容如下，这个无效的话可以再去官方 github 项目文件里找找，我网上找了几个都有问题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML for static distribution bundle build --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>%(DocumentTitle)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./swagger-ui.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./favicon-32x32.png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;32x32&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./favicon-16x16.png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;16x16&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow</span>: -moz-scrollbars-vertical;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *,</span></span><br><span class="line"><span class="language-css">        *<span class="selector-pseudo">:before</span>,</span></span><br><span class="line"><span class="language-css">        *<span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: inherit;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="number">#fafafa</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    %(HeadContent)</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;swagger-ui&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Workaround for https://github.com/swagger-api/swagger-editor/issues/1371 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;Edge&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Removing native Edge fetch in favor of swagger-ui&#x27;s polyfill&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./swagger-ui-bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./swagger-ui-standalone-preset.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* Source: https://gist.github.com/lamberta/3768814</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * Parse a string function definition and return a function object. Does not use eval.</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * @param &#123;string&#125; str</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * @return &#123;function&#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         *</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         * Example:</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         *  var f = function (x, y) &#123; return x * y; &#125;;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         *  var g = parseFunction(f.toString());</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         *  g(33, 3); //=&gt; 99</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">         */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">parseFunction</span>(<span class="params">str</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="keyword">void</span> (<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> fn_body_idx = str.<span class="title function_">indexOf</span>(<span class="string">&#x27;&#123;&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript">                fn_body = str.<span class="title function_">substring</span>(fn_body_idx + <span class="number">1</span>, str.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;&#125;&#x27;</span>)),</span></span><br><span class="line"><span class="language-javascript">                fn_declare = str.<span class="title function_">substring</span>(<span class="number">0</span>, fn_body_idx),</span></span><br><span class="line"><span class="language-javascript">                fn_params = fn_declare.<span class="title function_">substring</span>(fn_declare.<span class="title function_">indexOf</span>(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>, fn_declare.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;)&#x27;</span>)),</span></span><br><span class="line"><span class="language-javascript">                args = fn_params.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            args.<span class="title function_">push</span>(fn_body);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="title class_">Function</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> configObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;%(ConfigObject)&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> oauthConfigObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;%(OAuthConfigObject)&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// Workaround for https://github.com/swagger-api/swagger-ui/issues/5945</span></span></span><br><span class="line"><span class="language-javascript">            configObject.<span class="property">urls</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (item.<span class="property">url</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;http&quot;</span>) || item.<span class="property">url</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;/&quot;</span>)) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">                item.<span class="property">url</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">replace</span>(<span class="string">&quot;index.html&quot;</span>, item.<span class="property">url</span>).<span class="title function_">split</span>(<span class="string">&#x27;#&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// If validatorUrl is not explicitly provided, disable the feature by setting to null</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!configObject.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;validatorUrl&quot;</span>))</span></span><br><span class="line"><span class="language-javascript">                configObject.<span class="property">validatorUrl</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// If oauth2RedirectUrl isn&#x27;t specified, use the built-in default</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!configObject.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;oauth2RedirectUrl&quot;</span>))</span></span><br><span class="line"><span class="language-javascript">                configObject.<span class="property">oauth2RedirectUrl</span> = (<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;oauth2-redirect.html&quot;</span>, <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>)).<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// Apply mandatory parameters</span></span></span><br><span class="line"><span class="language-javascript">            configObject.<span class="property">dom_id</span> = <span class="string">&quot;#swagger-ui&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            configObject.<span class="property">presets</span> = [<span class="title class_">SwaggerUIBundle</span>.<span class="property">presets</span>.<span class="property">apis</span>, <span class="title class_">SwaggerUIStandalonePreset</span>];</span></span><br><span class="line"><span class="language-javascript">            configObject.<span class="property">layout</span> = <span class="string">&quot;StandaloneLayout&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// Parse and add interceptor functions</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> interceptors = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;%(Interceptors)&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (interceptors.<span class="property">RequestInterceptorFunction</span>)</span></span><br><span class="line"><span class="language-javascript">                configObject.<span class="property">requestInterceptor</span> = <span class="title function_">parseFunction</span>(interceptors.<span class="property">RequestInterceptorFunction</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (interceptors.<span class="property">ResponseInterceptorFunction</span>)</span></span><br><span class="line"><span class="language-javascript">                configObject.<span class="property">responseInterceptor</span> = <span class="title function_">parseFunction</span>(interceptors.<span class="property">ResponseInterceptorFunction</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// Begin Swagger UI call region</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> ui = <span class="title class_">SwaggerUIBundle</span>(configObject);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            ui.<span class="title function_">initOAuth</span>(oauthConfigObject);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// End Swagger UI call region</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">ui</span> = ui</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>Startup.Configure</code>的 UseSwaggerUI 中间件的配置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启用中间件服务对swagger-ui，指定Swagger JSON终结点</span></span><br><span class="line">app.UseSwaggerUI(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.SwaggerEndpoint(<span class="string">&quot;/swagger/v1/swagger.json&quot;</span>, <span class="string">&quot;My API V1&quot;</span>);</span><br><span class="line">    c.RoutePrefix = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增下面</span></span><br><span class="line">    c.IndexStream = () =&gt; GetType().GetTypeInfo()</span><br><span class="line">      .Assembly.GetManifestResourceStream(<span class="string">&quot;&lt;your-project-namespace&gt;.index.html&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>&lt;your-project-namespace&gt;</code>需改为自己的</p>
<p>假如<code>&lt;your-project-namespace&gt;</code>这里填错了，会报下面错误</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ArgumentNullException: Value cannot be <span class="literal">null</span>. (Parameter <span class="string">&#x27;stream&#x27;</span>)</span><br><span class="line">        System.IO.StreamReader..ctor(Stream stream, Encoding encoding, <span class="built_in">bool</span> detectEncodingFromByteOrderMarks, <span class="built_in">int</span> bufferSize, <span class="built_in">bool</span> leaveOpen)</span><br><span class="line">        Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.RespondWithIndexHtml(HttpResponse response)</span><br><span class="line">        Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)</span><br><span class="line">        Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)</span><br><span class="line">        Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)</span><br></pre></td></tr></table></figure>

<p>所以我后来改了写法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得当前程序集的名字</span></span><br><span class="line"><span class="built_in">string</span> projectName = System.Reflection.Assembly.GetExecutingAssembly().GetName().Name; </span><br><span class="line">c.IndexStream = () =&gt; GetType().GetTypeInfo().Assembly.GetManifestResourceStream(<span class="string">$&quot;<span class="subst">&#123;projectName&#125;</span>.index.html&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样改了项目名就可以动态获得，当然还是有其他问题，不过一般也够用了</p>
</li>
<li><p><strong>获取MiniProfiler相关Script片段</strong>，这个很重要，网上很多教程就直接给一个&lt;script&gt;代码给人使用，但是版本不匹配的话会出问题</p>
<p>在其中一个Controller里添加该方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;GetMiniProfilerScript&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetMiniProfilerScript</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> html = MiniProfiler.Current.RenderIncludes(HttpContext);</span><br><span class="line">    <span class="keyword">return</span> Ok(html.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行项目访问该方法，获得其内容，类似下面，实际就是一段&lt;script&gt;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>=<span class="string">&quot;async&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mini-profiler&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/profiler/includes.min.js?v=4.2.22+4563a9e1ab&quot;</span> <span class="attr">data-version</span>=<span class="string">&quot;4.2.22+4563a9e1ab&quot;</span> <span class="attr">data-path</span>=<span class="string">&quot;/profiler/&quot;</span> <span class="attr">data-current-id</span>=<span class="string">&quot;82827eb7-0fbf-46ac-a21b-d8547627b53b&quot;</span> <span class="attr">data-ids</span>=<span class="string">&quot;9871c780-0c60-4b17-a5ba-0b4b848c6ef9,82827eb7-0fbf-46ac-a21b-d8547627b53b&quot;</span> <span class="attr">data-position</span>=<span class="string">&quot;Left&quot;</span>&quot; <span class="attr">data-scheme</span>=<span class="string">&quot;Light&quot;</span> <span class="attr">data-authorized</span>=<span class="string">&quot;true&quot;</span> <span class="attr">data-max-traces</span>=<span class="string">&quot;15&quot;</span> <span class="attr">data-toggle-shortcut</span>=<span class="string">&quot;Alt+P&quot;</span> <span class="attr">data-trivial-milliseconds</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">data-ignored-duplicate-execute-types</span>=<span class="string">&quot;Open,OpenAsync,Close,CloseAsync&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>把上面获取到的script片段加入到index.html文件的最前面</p>
</li>
<li><p>重新启动项目，随意访问一个接口，然后就能看到页面左上方有一个浮动窗显示<code>xxx ms</code>，点击该面板就能看到熟悉的MiniProfiler分析界面</p>
</li>
</ol>
<h3 id="再次强调"><a href="#再次强调" class="headerlink" title="再次强调"></a>再次强调</h3><ol>
<li><p>网上的一些教程的 index.html 就是乱搞的，我试过几个都有问题，如果我的也有问题，只能自己再找找</p>
</li>
<li><p>MiniProfiler 相关 Script 片段这个最好不要随意使用别人给的，版本号很难刚好与自己所需版本匹配，还是使用上面提供的获取办法自己获取最好</p>
</li>
</ol>
<p>  该部分内容参考文章：<a href="https://www.cnblogs.com/xuke/p/13847248.html">WebAPI性能监控-MiniProfiler与Swagger集成</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>Swagger</tag>
        <tag>MiniProfiler</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NETCore的Filter</title>
    <url>/2022/01/+ASP.NETCore%E7%9A%84Filter/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="什么是Filter"><a href="#什么是Filter" class="headerlink" title="什么是Filter"></a>什么是Filter</h2><p>过滤器（Filter）是 AOP[^AOP] 思想的一种实现，让我们在执行管道（pipeline）的特定阶段（之前或之后）执行代码，管道在选择了要执行的操作之后运行。</p>
<p>下面图片显示了管道所在位置</p>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-1.png" alt="aspnetcore-filter-pipeline-1.png"></p>
<p>通过使用过滤器可以实现 <strong>短路请求、缓存请求结果、日志统一记录、参数合法性验证、异常统一处理、返回值格式化</strong> 等，同时使业务代码更加简洁单纯，避免很多重复代码。</p>
<span id="more"></span>

<h2 id="5种Filter"><a href="#5种Filter" class="headerlink" title="5种Filter"></a>5种Filter</h2><h3 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h3><ul>
<li><p><strong><a href="#Authorizaion-Filter">Authorizaion Filter</a></strong> ：<strong>授权过滤器</strong></p>
<p>Authorization是五种Filter中最先运行的，用于确定是否已针对请求为用户授权。 如果请求未获授权，可以让管道短路。</p>
<p><strong>作用</strong>：主要用于实现复杂的<code>权限角色认证</code>、<code>登陆授权</code>等操作。</p>
</li>
<li><p><strong><a href="#Resource-Filter">Resource Filter</a></strong> ：<strong>资源过滤器</strong></p>
<p>OnResourceExecuting：在Authorization之后，Model Binding之前执行，对<strong>实现缓存或者对过滤管道进行短路</strong>特别有用。</p>
<p>OnResourceExecuted：在管道的其余阶段完成之后运行代码。</p>
<p><strong>作用</strong>：主要用于进行<code>资源缓存</code>、<code>防盗链</code>等操作。</p>
</li>
<li><p><strong><a href="#Exception-Filter">Exception Filter</a></strong> ：<strong>异常过滤器</strong></p>
<p>异常处理的Filter，在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。</p>
<p><strong>作用</strong>：可以进行全局的<code>异常日志收集</code>、<code>错误信息友好化处理</code>等操作。</p>
</li>
<li><p><strong><a href="#Action-Filter">Action Filter</a></strong> ：<strong>操作过滤器</strong></p>
<p>最常使用的Filter，实际上包围了整个Action。</p>
<p>OnActionExecuting：执行实际Action操作前触发，更改传递到操作中的参数。</p>
<p>OnActionExecuted：执行实际Action操作后触发，更改从操作返回的结果。</p>
<p><strong>作用</strong>：做法太多了，可以用于<code>执行操作日志</code>、<code>参数验证</code>，<code>权限控制</code>等一系列操作。</p>
</li>
<li><p><strong><a href="#Result-Filter">Result Filter</a></strong> ：<strong>结果过滤器</strong></p>
<p>在执行操作结果之前和之后立即运行代码。<strong>仅当操作方法成功执行时，它们才会运行</strong>。对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。</p>
<p>OnResultExecuting：在操作结果执行之前调用。</p>
<p>OnResultExecuted：在操作结果执行之后调用。</p>
<p><strong>作用</strong>：可以对结果进行<code>格式化</code>、<code>大小写转换</code>、<code>缓存结果</code>等一系列操作。</p>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>下图是我自制的一个比较完整的请求在<code>Filter Pipeline</code>中的流动的流程图。</p>
<p>需要特别注意的是<code>Exception Filter</code>的位置：</p>
<ul>
<li><p>在<strong>它位置之下</strong>的流程中抛出的错误才会被其捕捉处理，然后再流经<code>Resource Filter</code>的<code>OnResourceExecuted</code>方法后出去。</p>
</li>
<li><p>在<code>Exception Filter</code>之上的<code>Authorizaion Filter</code>与<code>Resource Filter</code>抛出的错误实际都不会被<code>Exception Filter</code>捕捉处理。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hushitong/CloudImg/main/data/aspnetcore-filter-pipeline-2.jpg" alt="aspnetcore-filter-pipeline-2.jpg (1003×1344) (raw.githubusercontent.com)"></p>
<p>所有Filter均可通过不同的接口定义支持同步和异步的实现。根据需要执行的任务类型，选择同步或异步实现。</p>
<p>通过设置 <strong>Context.Result</strong> 来截断请求，可以是使Filter管道短路。</p>
<p><strong>注意：</strong>下面的例子优先使用同步方式实现。下面的例子是一个WebApi项目。</p>
<h3 id="Authorizaion-Filter"><a href="#Authorizaion-Filter" class="headerlink" title="Authorizaion Filter"></a>Authorizaion Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnAuthorizationAsync</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>AuthorizationFilterAsync</code>方法</p>
<p>下面是一个实际的鉴权例子，由我以前一个WebApi项目改造而来</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Authorization;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Controllers;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorizationFilter</span> : <span class="title">IAuthorizationFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAuthorization</span>(<span class="params">AuthorizationFilterContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;AuthorizationFilter.OnAuthorization, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否能被匿名调用</span></span><br><span class="line">            <span class="keyword">var</span> action = context.ActionDescriptor <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">var</span> allowAnonymousAttr = action.MethodInfo.GetCustomAttribute&lt;AllowAnonymousAttribute&gt;();</span><br><span class="line">            <span class="built_in">bool</span> isAllowAnonymous = allowAnonymousAttr == <span class="literal">null</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//能被匿名调用，则继续执行；</span></span><br><span class="line">            <span class="comment">//不能被匿名调用，则验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isAllowAnonymous == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//验证是否授权访问，如果授权未通过，则抛出“未授权访问”信息，流程不在往下走</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对异常进行处理，需要注意抛出的异常不能被Exception Filter所捕获，因此不要想着直接throw出去</span></span><br><span class="line">                context.Result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;鉴权服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;); ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;AuthorizationFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是如果在Authorizaion Filter中抛出的异常，那 <strong>并不会被Exception Filter所捕获</strong></p>
<h3 id="Resource-Filter"><a href="#Resource-Filter" class="headerlink" title="Resource Filter"></a>Resource Filter</h3><p>同步：继承<code>IResourceFilter</code>接口，实现<code>OnResourceExecuting</code>与<code>OnResourceExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResourceFilter</code>接口，实现<code>OnResourceExecutionAsync</code>方法，注意没有<code>OnResourceExecutedAsync</code>这个方法</p>
<p>下面是简单的页面缓存例子，在<code>OnResourceExecuted</code>获得缓存，在</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourceFilter</span> : <span class="title">IResourceFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuting</span>(<span class="params">ResourceExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，有就获得缓存内的value，然后构造response再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResourceExecuted</span>(<span class="params">ResourceExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ResourceFilter.OnResourceExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否由以该Request.Path为key的缓存，没有就保存到缓存，再返回</span></span><br><span class="line">            <span class="keyword">var</span> cacheKey = context.HttpContext.Request.Path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exception-Filter"><a href="#Exception-Filter" class="headerlink" title="Exception Filter"></a>Exception Filter</h3><p>同步：继承<code>IExceptionFilter</code>接口，实现<code>OnException</code>方法</p>
<p>异步：继承<code>IAsyncExceptionFilter</code>接口，实现<code>OnExceptionAsync</code>方法</p>
<p>下面例子catch了所有错误并进行处理</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExceptionFilter</span> : <span class="title">IExceptionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnException</span>(<span class="params">ExceptionContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ExceptionFilter.OnException, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ObjectResult result;</span><br><span class="line">            <span class="keyword">var</span> isShowDevExceptionMsg = <span class="string">&quot;false&quot;</span>;</span><br><span class="line">            <span class="comment">//isShowDevExceptionMsg = configuration.GetSection(&quot;IsShowDevExceptionMsg&quot;).Value;  //由配置得到</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(isShowDevExceptionMsg) &amp;&amp; isShowDevExceptionMsg.ToLower() == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span>, devMsg = context.Exception.Message &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ObjectResult(<span class="keyword">new</span> &#123; rtnCode = <span class="number">500</span>, msg = <span class="string">&quot;服务发生错误，请稍后重试或联系管理人员&quot;</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.StatusCode = <span class="number">500</span>;</span><br><span class="line">            context.Result = result;</span><br><span class="line">            context.ExceptionHandled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ExceptionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建FilterTestController.cs添加测试用Action</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意<code>Context.ExceptionHandled = true</code>，设置后 <strong>标记异常已被处理，异常不会再抛出，后续的Exception Filter不会再触发</strong> 。</p>
<h3 id="Action-Filter"><a href="#Action-Filter" class="headerlink" title="Action Filter"></a>Action Filter</h3><p>同步：继承<code>IActionFilter</code>接口，实现<code>OnActionExecuting</code>与<code>OnActionExecuted</code>方法</p>
<p>异步：继承<code>IAsyncActionFilter</code>接口，实现<code>OnActionExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//做权限校验或参数验证等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ActionFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意异步的写法，<code>await next();</code>会调用<code>Action</code>或下一个<code>Action Filter</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterAsync</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnActionExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnActionExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，同步于异步是能同时使用的</p>
<p>使用Action Filter的案例：</p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=135">案例：自动启用事务的ActionFilter</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He?p=136">案例：对请求限速的ActionFilter</a></p>
<h3 id="Result-Filter"><a href="#Result-Filter" class="headerlink" title="Result Filter"></a>Result Filter</h3><p>同步：继承<code>IResultFilter</code>接口，实现<code>OnResultExecuting</code>与<code>OnResultExecuted</code>方法</p>
<p>异步：继承<code>IAsyncResultFilter</code>接口，实现<code>OnResultExecutionAsync</code>方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilter</span> : <span class="title">IResultFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuting</span>(<span class="params">ResultExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Response的Header添加信息</span></span><br><span class="line">            context.HttpContext.Response.Headers.Add(<span class="string">&quot;MoreInfo&quot;</span>, <span class="string">&quot;Just a test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResultExecuted</span>(<span class="params">ResultExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里就不能再在Header添加信息了</span></span><br><span class="line">            <span class="comment">//还可以在这里缓存结果内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResultFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步，与<code>Action Filter</code>的异步类似</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultFilterAsync</span> : <span class="title">IAsyncResultFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnResultExecutionAsync</span>(<span class="params">ResultExecutingContext context, ResultExecutionDelegate next</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Before Action，相当于同步的OnResultExecuting</span></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="comment">//After Action，相当于同步的OnResultExecuted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的注册"><a href="#Filter的注册" class="headerlink" title="Filter的注册"></a>Filter的注册</h2><p>Filter有三种注册方式<code>Action</code>、<code>Controller</code>、<code>全局</code> ，其作用域<code>由低到高</code>。</p>
<h3 id="Action注册"><a href="#Action注册" class="headerlink" title="Action注册"></a>Action注册</h3><p>只针对特定的 Action，影响最小，适合于对特定 Action 进行特殊处理。</p>
<p>使用<code>[TypeFilter(Type)]</code>进行注册，如注册上面例子的 ResourceFilter。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller注册"><a href="#Controller注册" class="headerlink" title="Controller注册"></a>Controller注册</h3><p>影响该 Controller 下的所有 Action。</p>
<p>与上面<code>Action注册</code>的办法一样，通过<code>[TypeFilter(Type)]</code>进行注册。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">TypeFilter(typeof(ResourceFilter))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FilterTestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>前面的例子使用的就是全局注册方式，该方式会影响到所有的进入<code>Filter Pipeline</code>的请求。</p>
<p>该注册方式能够很好的进行一些需要影响全局的处理，如：全局的异常处理、全局的日志记录</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        config.Filters.Add&lt;ResourceFilter&gt;();</span><br><span class="line">        <span class="comment">//下面的也可以，不过不推荐</span></span><br><span class="line">        <span class="comment">//config.Filters.Add(new ResourceFilter());</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeFilter-和-ServiceFilter-注册方式"><a href="#TypeFilter-和-ServiceFilter-注册方式" class="headerlink" title="TypeFilter 和 ServiceFilter 注册方式"></a>TypeFilter 和 ServiceFilter 注册方式</h3><p>前面的<code>Action注册</code>与<code>Controller注册</code>使用的都是<code>TypeFilter</code>的方式注册，实际还可以用<code>ServiceFilter</code>来注册，两者的异同为：</p>
<ul>
<li>ServiceFilter和TypeFilter都实现了IFilterFactory，因此都可以使用注册的Filter中构造函数中注入的对象，不需要特殊处理。</li>
<li>ServiceFilter需要对自定义的Filter进行注册，TypeFilter不需要。</li>
<li>ServiceFilter的Filter生命周期源自于您如何注册，而TypeFilter每次都会创建一个新的实例。</li>
</ul>
<p>使用<code>ServiceFilter</code>进行<code>Action注册</code>例子如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;TestException&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ServiceFilter(typeof(ExceptionFilter))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">TestException</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//startup.cs文件里注册</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddTransient&lt;ExceptionFilter&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特性化"><a href="#特性化" class="headerlink" title="特性化"></a>特性化</h2><p>编写Filter时多继承Attribute类就能像普通特性一般使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">FilterTest.Attributes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于有构造函数的，且其构造函数的参数是由DI容器注入的，则需要在已编写完成的Filter外再加一层，通过继承<code>TypeFilterAttribute</code>来实现，而<code>TypeFilterAttribute</code>实现<code>IFilterFactory</code>接口，<code>IFilterFactory</code> 公开用于创建<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifiltermetadata">IFilterMetadata</a>实例的<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory.createinstance">CreateInstance</a>方法，<code>CreateInstance</code>从服务容器 (DI) 中加载指定的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterWithDIAttribute</span> : <span class="title">TypeFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyActionFilterWithDIAttribute</span>() : <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(ActionFilterWithDI</span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActionFilterWithDI</span> : <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里注入了IConfiguration</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActionFilterWithDI</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="comment">//throw new Exception(&quot;ActionFilter.OnActionExecuting Exception&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****ActionFilterWithDI.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接使用</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilterWithDI</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Filter的执行顺序"><a href="#Filter的执行顺序" class="headerlink" title="Filter的执行顺序"></a>Filter的执行顺序</h2><h3 id="相同类型的Filter不同注册方式的执行顺序"><a href="#相同类型的Filter不同注册方式的执行顺序" class="headerlink" title="相同类型的Filter不同注册方式的执行顺序"></a>相同类型的Filter不同注册方式的执行顺序</h3><p>首先对于同类型Filter同样注册方式的Filter，其执行顺序默认时先加的先执行。</p>
<p>而对于同类型Filter不同注册方式（action、Controller、全局）的Filter，以Aciton Filter为例其默认执行顺序如下：</p>
<ul>
<li><p>OnActionExecuting(全局)</p>
<ul>
<li><p>OnActionExecuting(Controller)</p>
<ul>
<li><p>OnActionExecuting(action)</p>
<ul>
<li>Action</li>
</ul>
</li>
<li><p>OnActionExecuted(action)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(Controller)</p>
</li>
</ul>
</li>
<li><p>OnActionExecuted(全局)</p>
</li>
</ul>
<p>可以看到非常符合AOP的风格。</p>
<h3 id="改变执行顺序"><a href="#改变执行顺序" class="headerlink" title="改变执行顺序"></a>改变执行顺序</h3><p>虽然默认的执行顺序如上，但是我们是可以更改其执行顺序的，只要我们创建Filter的时候同时实现<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter">IOrderedFilter</a>接口，就能在注册时附带上排序值，数值越小优先权越高，没设置的默认值为0，默认值相等的按照上面的规则执行。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyActionFilterAttribute</span> : <span class="title">Attribute</span>, <span class="title">IActionFilter</span>, <span class="title">IOrderedFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">//实现的时候IOrderedFilter需要声明一个order属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuting, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;****MyActionFilterAttribute.OnActionExecuted, Request Path: <span class="subst">&#123;context.HttpContext.Request.Path&#125;</span>, Time: <span class="subst">&#123;DateTime.Now.ToString(<span class="string">&quot;hh:mm:ss ffff&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时设置Order属性，如设置-1提升其优先权</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">MyActionFilter(Order = -1)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">ASP.NET Core Filters</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/112508518">Asp.Net Core Filter 深入浅出的那些事-AOP</a></p>
<p><a href="https://www.cnblogs.com/snaildev/p/9154669.html">ASP.NET Core 2 学习笔记（十四）Filters</a></p>
<p>[^AOP]:面向切面编程（AOP是Aspect Oriented Program的首字母缩写），在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>Filter</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core缓存</title>
    <url>/2022/01/+ASP.NETCore%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Caching通过减少生成内容所需的工作，显著提高应用的性能和可伸缩性。 Caching最适用于不经常更改且 <strong>生成成本高</strong> 的数据。 Caching可比从源返回快得多的数据副本。</p>
<p>ASP.NET Core支持多个不同的缓存</p>
<ul>
<li>客户端缓存 Cache-control</li>
<li>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></li>
<li>内存缓存  <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory">In-MemoryCache</a></li>
<li>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></li>
</ul>
<span id="more"></span>

<h2 id="缓存准则"><a href="#缓存准则" class="headerlink" title="缓存准则"></a>缓存准则</h2><ul>
<li>代码应始终具有用于提取数据的选项，而不是依赖于可用的缓存值。</li>
<li>缓存的是内存资源，内存资源是有限的因此需要限制缓存增长：<ul>
<li>请勿将外部输入用作缓存Key，如果任由外部输入作为Key，那缓存很容易就会被恶意刷爆。</li>
<li>使用过期时间策略限制缓存增长，这能够及时释放不活跃的缓存，及时释放内存空间。</li>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory?view=aspnetcore-3.1#use-setsize-size-and-sizelimit-to-limit-cache-size">使用 SetSize、Size 和 SizeLimit 限制缓存大小</a>。 ASP.NET Core运行时 <strong>不会根据</strong> 内存压力限制缓存大小。 由开发人员限制缓存大小。</li>
</ul>
</li>
</ul>
<h2 id="客户端缓存-Cache-control"><a href="#客户端缓存-Cache-control" class="headerlink" title="客户端缓存 Cache-control"></a>客户端缓存 Cache-control</h2><p>Http协议中规定，服务器端通过返回报文头添加Cache-control，来达到通知客户端进行缓存，如：<code>Cache-control:max-age=30</code>，表示让客户端缓存该内容30秒（当然客户端也可以不干）。</p>
<p>在ASP.NET Core中，可以通过添加<code>ResponseCacheAttribute</code>这个Attribute，让程序在返回时的添加报文头<code>Cache-control</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端缓存只对本客户端有效，在你使用另一个客户端发出一样的请求是，你就会发现访问的不是缓存了的数据，而是最新数据。这时候就需要使用服务端缓存了。</p>
<h2 id="服务器端响应缓存-ResponseCaching"><a href="#服务器端响应缓存-ResponseCaching" class="headerlink" title="服务器端响应缓存 ResponseCaching"></a>服务器端响应缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware">ResponseCaching</a></h2><p>ASP.NET Core不但可以设置浏览器缓存，还可以设置服务器端的响应缓存，当请求某资源时，响应的内容会被服务器进行缓存，在缓存有效期内，就算不同客户端获取同一资源也不会真的进入该资源地址获取数据，而是由缓存直接返回内容。</p>
<h3 id="使用ResponseCaching"><a href="#使用ResponseCaching" class="headerlink" title="使用ResponseCaching"></a>使用ResponseCaching</h3><p>要使用服务器缓存，需要以下步骤：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.Configure</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure></li>
<li><p>同样需要添加<code>ResponseCacheAttribute</code>这个Attribute：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 30)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;<span class="built_in">bool</span>&gt; <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> accId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.Validate(accID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这时候你通过同一客户端多次访问该资源发现第二次以后的访问的是客户端缓存，通过不同客户端访问的是服务器缓存的内容。</p>
<p>上面的例子用的是 MemoryCache 作为储存介质，如果应用重启了，缓存的数据就会失效。</p>
<h3 id="ResponseCaching的缓存条件"><a href="#ResponseCaching的缓存条件" class="headerlink" title="ResponseCaching的缓存条件"></a>ResponseCaching的缓存条件</h3><ul>
<li>请求必须生成状态代码为”正常”的 200 (服务器) 响应。</li>
<li>请求方法必须是 GET 或 HEAD。</li>
<li>在 <code>Startup.Configure</code> 中，Caching中间件的中间件之前必须放置需要缓存的中间件。 有关详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1">ASP.NET Core 中间件</a>。</li>
<li><code>Authorization</code>标头不能存在。</li>
<li><code>Cache-Control</code> 标头参数必须有效，并且响应必须标记 <code>public</code> 且未标记为 <code>private</code> 。</li>
<li>如果标头不存在，则标头不得存在，因为标头 <code>Pragma: no-cache</code> <code>Cache-Control</code> 将替代标头（ <code>Cache-Control</code> <code>Pragma</code> 如果存在）。</li>
<li><code>Set-Cookie</code>标头不能存在。</li>
<li><code>Vary</code> 标头参数必须有效且不等于 <code>*</code> 。</li>
<li>如果 <code>Content-Length</code> 设置了 (标头值) 必须与响应正文的大小匹配。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.features.ihttpsendfilefeature">IHttpSendFileFeature</a>未使用 。</li>
<li>响应不能像 标头和 和 缓存 <code>Expires</code> 指令所指定 <code>max-age</code> 一 <code>s-maxage</code> 样过时。</li>
<li>响应缓冲必须成功。 响应的大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.sizelimit#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_SizeLimit">SizeLimit</a> 。 响应的正文大小必须小于配置的 或默认的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.responsecaching.responsecachingoptions.maximumbodysize#Microsoft_AspNetCore_ResponseCaching_ResponseCachingOptions_MaximumBodySize">MaximumBodySize</a> 。</li>
<li>响应必须可缓存，符合 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 规范。 例如，指令 <code>no-store</code> 不得存在于请求或响应标头字段中。 有关详细信息 <em>，请参阅第 3</em> 部分：在 <a href="https://tools.ietf.org/html/rfc7234">RFC 7234</a> 的缓存中存储响应。</li>
</ul>
<h3 id="ResponseCaching只是看上去美好"><a href="#ResponseCaching只是看上去美好" class="headerlink" title="ResponseCaching只是看上去美好"></a>ResponseCaching只是看上去美好</h3><p>虽然服务器端响应缓存看起来很美好，不过实际上有点中看不中用，应为其生效是有条件的，而且还挺苛刻，实际上只要请求的报文头加上<code>Cache-Control:no-cache</code>，就可以让服务器响应缓存失效。所以一般我们更加依赖于：<code>内存缓存</code>、<code>分布式缓存</code>。</p>
<h2 id="内存缓存-IMemoryCache"><a href="#内存缓存-IMemoryCache" class="headerlink" title="内存缓存  IMemoryCache"></a>内存缓存  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.memory.imemorycache">IMemoryCache</a></h2><p>内存缓存是数据保存在当前运行的网站的内存中，是与进程相关的。而由于在Web服务器中，多个不同网站时运行在不同进程中的，因此不同网站的内存时不会互相干扰的，也就意味着不能直接访问不在同一进程中的其他应用程序的内存缓存，然后需要注意的是网站重启后，内存缓存中的数据会清空。</p>
<h3 id="使用内存缓存"><a href="#使用内存缓存" class="headerlink" title="使用内存缓存"></a>使用内存缓存</h3><p>要使用内存缓存，需要：</p>
<ol>
<li><p>在<code>Startup.ConfigureServices</code>中添加：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">services.AddMemoryCache();</span><br></pre></td></tr></table></figure></li>
<li><p>注入<code>IMemoryCache</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = memoryCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>TryGetValue</code>、<code>Remove</code>、<code>Set</code>、<code>GetOrCreate</code>等方法操作MemoryCache</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryCacheController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMemoryCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheController</span>(<span class="params">IMemoryCache memoryCache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = memoryCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> serverTime;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 读取写入缓存</span></span><br><span class="line">        <span class="comment">//方法一、使用TryGetValue与Set</span></span><br><span class="line">        <span class="comment">//if (!_cache.TryGetValue(&quot;servertime&quot;, out serverTime))</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    serverTime = DateTime.Now.ToString(&quot;F&quot;);</span></span><br><span class="line">        <span class="comment">//    _cache.Set(&quot;servertime&quot;, serverTime);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//方法二、使用GetOrCreate</span></span><br><span class="line">        <span class="comment">//serverTime = _cache.GetOrCreate&lt;string&gt;(&quot;serverTime&quot;, (e) =&gt; &#123; return DateTime.Now.ToString(&quot;F&quot;);&#125;);</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> serverTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Remove&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">string</span> cacheName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache.Remove(cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>访问<code>Get</code>方法获得数据并设置一个名字为 **servertime **的MemoryCache，在过期前再次访问获得的都是MemoryCache里的数据，可以通过访问<code>Remove</code>方法，传入参数”servertime “，即可清除名字为”servertime “的MemoryCache。</p>
<h3 id="过期时间策略"><a href="#过期时间策略" class="headerlink" title="过期时间策略"></a>过期时间策略</h3><p>默认情况下内存缓存是不会过期的，因此我们可以通过<code>Remove</code>方法删除缓存，或者使用<code>Set</code>方法重新设置缓存，不过在实际应用中大部分时间不会这么做，因为这么弄很麻烦，更常用的办法时使用过期时间来管理。</p>
<p>过期时间策略有两种</p>
<ul>
<li><p>绝对过期时间，通过设置<code>ICacheEntry.AbsoluteExpirationRelativeToNow</code>(过多少时间后失效)或<code>ICacheEntry.AbsoluteExpiration</code>(什么时间点失效)。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会过期</span></span><br><span class="line">serverTime = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;serverTime&quot;</span>, (e) =&gt; &#123; <span class="keyword">return</span> DateTime.Now.ToString(<span class="string">&quot;F&quot;</span>); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5秒后过期</span></span><br><span class="line">serverTime = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;servertime&quot;</span>, (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> DateTime.Now.ToString(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在今天晚上23点失效</span></span><br><span class="line">serverTime = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;servertime&quot;</span>, (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    e.AbsoluteExpiration = System.DateTime.Today.AddDays(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">return</span> DateTime.Now.ToString(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>滑动过期时间，通过设置<code>ICacheEntry.SlidingExpiration</code>(过多少时间后失效，但是如果在失效前一直有访问尽量，那就会延长设置的时间（注意是在被访问的时间点上），直到过期。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5秒后过期，假如在过期前被访问，以被访问时间点位基准再次延迟5秒，直到超过5秒无访问过期</span></span><br><span class="line">serverTime = _cache.GetOrCreate&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;servertime&quot;</span>, (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    e.SlidingExpiration = System.TimeSpan.FromSeconds(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> DateTime.Now.ToString(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>不过可以混用两种策略，让缓存数据能够在滑动过期时间的基础上，通过设置绝对过期时间来达到强制刷新数据的目的，也就是说在绝对过期时间这个点数据必定过期，滑动时间影响不了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//混用绝对过期时间与滑动过期时间</span></span><br><span class="line">serverTime = _cache.GetOrCreate(<span class="string">&quot;servertime&quot;</span>, (e) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(<span class="number">15</span>);  <span class="comment">//绝对过期时间15秒</span></span><br><span class="line">    e.SlidingExpiration = TimeSpan.FromSeconds(<span class="number">5</span>);  <span class="comment">//滑动过期时间5秒</span></span><br><span class="line">    <span class="keyword">return</span> DateTime.Now.ToString(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分布式缓存-DistributedCache"><a href="#分布式缓存-DistributedCache" class="headerlink" title="分布式缓存 DistributedCache"></a>分布式缓存 <a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">DistributedCache</a></h2><p>内存缓存在比较简单的应用里是足够使用的，但是对于现在需要多台服务器进行负载均衡的架构环境中就显得有点不太够用，如会出现：缓存内容不一致、多台服务器缓存同一内容浪费内存空间等问题，因此需要一个独立的统一的缓存存储中心，以便让所有的Web服务器共享同一份缓存数据，我们将这种缓存形式称为<strong>分布式缓存</strong>。</p>
<h3 id="有关-NET-Core的分布式缓存"><a href="#有关-NET-Core的分布式缓存" class="headerlink" title="有关.NET Core的分布式缓存"></a>有关.NET Core的分布式缓存</h3><ul>
<li><p>.NET Core没有内置分布式缓存，但是却提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法实际与内存缓存类似。</p>
</li>
<li><p>可以使用常用分布式缓存如<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>、<a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>、<a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>、<a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>等。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.SqlServer">SQL Server</a>：缓存性能并不好，基本不考虑。</p>
<p><a href="https://www.nuget.org/packages/EnyimMemcachedCore/">Memcached</a>：缓存专用，性能非常高能，可惜对集群、高可用方面支持比较弱，而且有<em>缓存键最大长度为250字节</em>（以前做项目刚用时就被坑过，超过了就直接截断，也没报错提醒）、<em>最大只能存储1MB的单个item</em>等限制。</p>
<p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis">Redis</a>：虽然做缓存服务器的性能比Memcached稍差，但是其高可用、集群等方面非常强大，适合在数据量大及集群等场景使用，并且缓存外的功能也很强大，还能做消息队列等。</p>
<p><a href="https://www.nuget.org/packages/NCache.Microsoft.Extensions.Caching.OpenSource">NCache</a>：它是一个高性能的、分布式的、可扩展的、天生为.Net设计的缓存框架，NCache不仅比 Redis 快，而且还提供了一些Redis所不具有的分布式特性。</p>
</li>
<li><p>分布式缓存其缓存值的类型为<code>byte[]</code>，虽然也提供了接受string的类型的方法，但是最终都会转换为<code>byte[]</code>，而且本身IDistributedCache提供的方法有限，最好扩展IDistributedCache的方法。</p>
</li>
</ul>
<h3 id="IDistributedCache接口包含以下方法"><a href="#IDistributedCache接口包含以下方法" class="headerlink" title="IDistributedCache接口包含以下方法"></a>IDistributedCache接口包含以下方法</h3><ul>
<li><p>Get、GetAsync</p>
<p>  采用字符串键并以byte[]形式检索缓存项（如果在缓存中找到）。</p>
</li>
<li><p>Set、SetAsync</p>
<p>  使用字符串键向缓存添加项byte[]形式）。</p>
</li>
<li><p>Refresh、RefreshAsync</p>
<p>  根据键刷新缓存中的项，并重置其可调过期超时值（如果有）。</p>
</li>
<li><p>Remove、RemoveAsync</p>
<p>  根据键删除缓存项。</p>
</li>
</ul>
<h3 id="Redis-分布式缓存"><a href="#Redis-分布式缓存" class="headerlink" title="Redis 分布式缓存"></a>Redis 分布式缓存</h3><ol>
<li><p>安装Redis相关包，这个包是微软提供的</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">install-package</span> Microsoft.Extensions.Caching.StackExchangeRedis</span><br><span class="line">//注意以前使用的是：Microsoft.Extensions.Caching.Redis包，不过这个包<span class="number">2018</span>年后就没更新了</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>Startup.ConfigureServices</code>中注册</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Use Redis</span></span><br><span class="line">services.AddStackExchangeRedisCache(options =&gt; &#123;</span><br><span class="line">    options.Configuration = <span class="string">&quot;localhost&quot;</span>;  <span class="comment">//使用本地</span></span><br><span class="line">    options.InstanceName = <span class="string">&quot;SampleInstance_&quot;</span>;  <span class="comment">//添加前缀可以区别于其他应用来的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>注入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _cache = cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IDistributedCache _cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisController</span>(<span class="params">IDistributedCache cache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Get&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Set&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Set</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> absoluteExpirationRelativeToNowSec = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> slidingExpirationSec = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加，注意：添加Redis后的类型是hash</span></span><br><span class="line">            <span class="comment">//默认没有过期时间</span></span><br><span class="line">            <span class="comment">//_cache.Set(&quot;id1&quot;, Encoding.Default.GetBytes(&quot;永不过期，缓存时间是：&#123;DateTime.Now.ToLongTimeString()&#125;&quot;), new DistributedCacheEntryOptions &#123; &#125;);</span></span><br><span class="line">            <span class="comment">//同样可以设置绝对过期时间与滑动过期时间</span></span><br><span class="line">            _cache.Set(</span><br><span class="line">                <span class="string">&quot;id1&quot;</span>,</span><br><span class="line">                Encoding.Default.GetBytes(<span class="string">$&quot;缓存时间是：<span class="subst">&#123;DateTime.Now.ToLongTimeString()&#125;</span>，过期时间是：<span class="subst">&#123;DateTime.Now.AddSeconds(absoluteExpirationRelativeToNowSec).ToLongTimeString()&#125;</span>&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> DistributedCacheEntryOptions</span><br><span class="line">                &#123;</span><br><span class="line">                    AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(absoluteExpirationRelativeToNowSec),</span><br><span class="line">                    SlidingExpiration = TimeSpan.FromSeconds(slidingExpirationSec)</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Del&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Del</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移除</span></span><br><span class="line">        _cache.Remove(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet(<span class="string">&quot;Refresh&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Refresh</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//刷新，Get命令同样会刷新滑动过期时间</span></span><br><span class="line">        _cache.Refresh(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> obj = _cache.Get(<span class="string">&quot;id1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="literal">null</span> ? <span class="string">&quot;Err：Not Found!&quot;</span> : Encoding.Default.GetString(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>访问一个缓存和数据库都不存在的key，由于该key注定获得不了数据，因此不会被写缓存，永远都会直接访问到数据库上。这种缓存永远起不了作用，直接被”穿透“到数据库的情况，被称为缓存穿透。</p>
<p> <strong>解决方案</strong>：</p>
<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>当出现这种请求时，也将其缓存，其key为请求的key，value为null，但是缓存有效时间设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>某一个热点key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>加互斥锁</strong>。在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</li>
<li><strong>热点数据不过期</strong>。直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>  缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p><strong>加互斥锁</strong>。同<a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>的。</p>
</li>
<li><p><strong>热点数据不过期</strong>。同<a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>的。</p>
</li>
<li><p><strong>错开过期时间</strong>。在基础过期时间的基础上，加上一个随机时间，防止同一时间大量数据过期现象发生。如：本来统一设置位3分钟的，变为3分钟加1-15秒的随机数。</p>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文章是基本上是基于ASP.NET Core3.1版本编写，其后续版本可能发生变化，具体使用请去<a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a>查看。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/overview">微软官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1pK41137He">.NET 6教程，.Net Core 2022视频教程，杨中科主讲</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/359118610">缓存穿透、缓存击穿、缓存雪崩解决方案</a></p>
]]></content>
      <categories>
        <category>Dev</category>
        <category>.NET Core</category>
        <category>ASP.NET Core</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>.NET Core</tag>
        <tag>Caching</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
</search>
